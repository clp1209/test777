From a1b61948287700bdd0e05625c92d4f41c0610082 Mon Sep 17 00:00:00 2001
From: Ramesh Garidapuri <ramesh.garidapuri@amd.com>
Date: Thu, 30 Nov 2023 12:00:57 +0530
Subject: [PATCH 19/33] eSPI CRC Error handling test changes

    Signed-off-by: Akshata MukundShetty <akshata.mukundshetty@amd.com>

Change-Id: I36f1bea4972b9062f04a54c24ec737f1c89d5d77
---
 drivers/spi/espi-amd.c   | 367 ++++++++++++++++++++++++---------------
 drivers/spi/espi-err.h   |  55 ++++++
 drivers/spi/espi.h       |  10 +-
 drivers/spi/espi_slave.h |   6 +
 4 files changed, 297 insertions(+), 141 deletions(-)
 create mode 100644 drivers/spi/espi-err.h

diff --git a/drivers/spi/espi-amd.c b/drivers/spi/espi-amd.c
index 467d02c60..d4cc31073 100644
--- a/drivers/spi/espi-amd.c
+++ b/drivers/spi/espi-amd.c
@@ -17,6 +17,7 @@
 #include <linux/slab.h>
 #include "espi.h"
 #include "espi_slave.h"
+#include "espi-err.h"
 
 #define ESPI_DEV_MINORS		0
 #define N_ESPI_MINORS           1
@@ -32,7 +33,6 @@
 #define ESPI_CONFIGURATION_HDATA0(a)		(((a) >> 8) & 0xff)
 #define ESPI_CONFIGURATION_HDATA1(a)		((a) & 0xff)
 
-
 enum amd_espi_versions {
 	AMD_ESPI_V1 = 1,     /* AMDI0070 */
 };
@@ -41,7 +41,6 @@ int espi_channel = 0;	//PC channel
 int espi_io_mode = 0;	//Single IO MODE
 int espi_op_freq = 16;	//16MHz
 
-
 struct amd_espi {
 	void __iomem *io_remap_addr;
 	unsigned long io_base_addr;
@@ -61,6 +60,9 @@ static struct class *amd_espi_dev_class;
 static struct cdev cdev;
 dev_t dev_minor;
 
+static int espi_send_cmd(struct amd_espi *amd_espi, struct espi_txcmd *cmd);
+static void espi_set_initial_config(struct amd_espi *amd_espi);
+
 void timer_callback(struct timer_list *timer)
 {
 	pr_info("AMD_ESPI: timer call back\n");
@@ -108,18 +110,94 @@ static int espi_poll_status(struct amd_espi *amd_espi, u32 *status)
 	return CB_ERR;
 }
 
+static int check_error_status(u32 status)
+{
+	u32 ret = 0;
+
+	if (!(status & ESPI_STATUS_DNCMD_COMPLETE)) { //did not complete downstream
+		ret =  ESPI_DOWNSTREAM_CMD_ERR;
+		pr_err("AMD_ESPI: eSPI downstream command completion failure\n");
+	} else if (status & ESPI_BUS_TIME_ERR) {
+		ret = ESPI_BUS_TIME_ERR;
+		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_BUS_TIMING]);
+	} else if (status & ESPI_BUS_WAIT_STATE_ERR) {
+		ret = ESPI_BUS_WAIT_STATE_ERR;
+		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_BUS_WAIT_STATE]);
+	} else if (status & ESPI_CRC_ERR) {
+		ret = ESPI_CRC_ERR;
+		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_CRC]);
+	} else if (status & ESPI_NO_RESP_ERR) {
+		ret = ESPI_NO_RESP_ERR;
+		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_NO_RESP]);
+	} else if (status & ESPI_FATAL_ERR) {
+		ret = ESPI_FATAL_ERR;
+		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_FATAL_ERR]);
+	} else if (status & ESPI_NON_FATAL_ERR) {
+		ret = ESPI_NON_FATAL_ERR;
+		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_NON_FATAL_ERR]);
+	} else if (status & ESPI_INVALID_RESP_CODE_ERR) {
+		ret = ESPI_INVALID_RESP_CODE_ERR;
+		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_INVALID_RESP_CODE]);
+	} else if (status & ESPI_INVALID_CYCLE_TYPE_ERR) {
+		ret = ESPI_INVALID_CYCLE_TYPE_ERR;
+		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_INVALID_CYCLE_TYPE]);
+	} else if (status & ESPI_UNSUCCESS_CPL_RECV) {
+		ret = ESPI_UNSUCCESS_CPL_RECV;
+		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_UNSUCCESS_CPL_RECV]);
+	} else if (status & ESPI_ILLEGAL_RESP_TAG_ERR) {
+		ret = ESPI_ILLEGAL_RESP_TAG_ERR;
+		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_ILLEGAL_RESP_TAG]);
+	} else if (status & ESPI_ILLEGAL_RESP_LEN) {
+		ret = ESPI_ILLEGAL_RESP_LEN;
+		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_ILLEGAL_RESP_LEN]);
+	} else if (status & ESPI_OOB_DATA_LEN_ERR) {
+		ret = ESPI_OOB_DATA_LEN_ERR;
+		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_OOB_DATA_LEN]);
+	} else if (status & ESPI_PC_MSG_DATA_LEN_ERR) {
+		ret = ESPI_PC_MSG_DATA_LEN_ERR;
+		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_PC_MSG_DATA]);
+	} else if (status & ESPI_FLASH_DATA_LEN_ERR) {
+		ret = ESPI_FLASH_DATA_LEN_ERR;
+		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_FLASH_DATA_LEN]);
+	} else if (status & ESPI_PROTOCOL_ERR) {
+		ret = ESPI_PROTOCOL_ERR;
+		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_PROTOCOL_ERR]);
+	} else
+		ret = CB_SUCCESS;
+
+	return ret;
+}
+
+static int amd_espi_inband_reset(struct amd_espi *amd_espi)
+{
+	u32 ret;
+	struct espi_txcmd cmd = {
+		.hdr0 = {
+			.cmd_type = IN_BAND_RESET,
+			.cmd_status = 1,
+		},
+	};
+
+	ret = espi_send_cmd(amd_espi, &cmd);
+	if(ret != CB_SUCCESS)
+		return ret;
+	else
+		espi_set_initial_config(amd_espi);
+	return CB_SUCCESS;
+}
+
 static int espi_send_cmd(struct amd_espi *amd_espi, struct espi_txcmd *cmd)
 {
 	u32 status;
-	u32 command_status = 0;
+	u32 ret = 0;
 
 	if (espi_ready_wait(amd_espi) != CB_SUCCESS)
 	{
 		pr_err("AMD_ESPI: %s, espi_ready_wait failed, before write\n", __func__);
 		pr_err("AMD_ESPI: eSPI cmd0-cmd2: %08x %08x %08x data: %08x.\n",
 				cmd->hdr0.val, cmd->hdr1.val, cmd->hdr2.val, cmd->data.val);
-		pr_err("AMD_ESPI: Error: eSPI was not ready to accept a command (Status = 0x%x)\n", status);
-		return CB_ERR;
+		pr_err("AMD_ESPI: Error: eSPI was not ready to accept a command\n");
+		return ESPI_DOWNSTREAM_CMD_ERR;
 	}
 	espi_clear_status(amd_espi);
 
@@ -129,14 +207,14 @@ static int espi_send_cmd(struct amd_espi *amd_espi, struct espi_txcmd *cmd)
 
 	writel(cmd->hdr0.val, (ESPI_BASE + AMD_ESPI_DS_HEADER_REG0));
 
-	command_status = readl(ESPI_BASE + AMD_ESPI_DS_HEADER_REG0);
 	if (espi_ready_wait(amd_espi) != CB_SUCCESS){
 		pr_err("AMD_ESPI: %s, espi_ready_wait failed, after write\n", __func__);
 		pr_err("AMD_ESPI: eSPI cmd0-cmd2: %08x %08x %08x data: %08x.\n",
 				cmd->hdr0.val, cmd->hdr1.val, cmd->hdr2.val, cmd->data.val);
-		pr_err("AMD_ESPI: Error: eSPI timed out waiting for command to complete (Status = 0x%x)\n", status);
-		return CB_ERR;
+		pr_err("AMD_ESPI: Error: eSPI timed out waiting for command to complete\n");
+		return ESPI_DOWNSTREAM_CMD_ERR;
 	}
+
 	if (espi_poll_status(amd_espi, &status) != CB_SUCCESS){
 		pr_err("AMD_ESPI: %s, espi_poll_status failed, after write\n", __func__);
 		pr_err("AMD_ESPI: eSPI cmd0-cmd2: %08x %08x %08x data: %08x.\n",
@@ -145,35 +223,24 @@ static int espi_send_cmd(struct amd_espi *amd_espi, struct espi_txcmd *cmd)
 		return CB_ERR;
 	}
 
-	/* If command did not complete downstream, return error. */
-	if (!(status & ESPI_STATUS_DNCMD_COMPLETE)) {
-		pr_err("AMD_ESPI: eSPI downstream command completion failure\n");
-		return CB_ERR;
-	}
+	ret = check_error_status(status);
+	if (ret != CB_SUCCESS) {
+		pr_err("AMD_ESPI: eSPI command packet:\n"
+				"Header-0: %08x\nHeader-1: %08x\n"
+				"Header-2: %08x\nData: %08x\n",	
+				cmd->hdr0.val, cmd->hdr1.val, cmd->hdr2.val, cmd->data.val);	
 
-	if (status & ~(ESPI_STATUS_DNCMD_COMPLETE | cmd->expected_status_codes)) {
-		pr_err("AMD_ESPI: %s, unexpected status code from slave\n", __func__);
-		pr_err("AMD_ESPI: eSPI cmd0-cmd2: %08x %08x %08x data: %08x.\n",
-				cmd->hdr0.val, cmd->hdr1.val, cmd->hdr2.val, cmd->data.val);
-		pr_err("AMD_ESPI: Error: unexpected eSPI status register bits set (Status = 0x%x)\n", status);
-		return CB_ERR;
+		pr_err("AMD_ESPI: eSPI status register bits set (Status = 0x%x)\n", status);
 	}
 
-	command_status = readl(ESPI_BASE + AMD_ESPI_DS_HEADER_REG0);
-	return CB_SUCCESS;
-}
-
-
-static int amd_espi_inband_reset(struct amd_espi *amd_espi)
-{
-	struct espi_txcmd cmd = {
-		.hdr0 = {
-			.cmd_type = IN_BAND_RESET,
-			.cmd_status = 1,
-		},
-	};
+	if (ret == ESPI_NO_RESP_ERR) {
+		pr_info("AMD_ESPI: Triggering Inband-reset after CRC Error\n");
+		if (amd_espi_inband_reset(amd_espi) != CB_SUCCESS) {
+                	pr_err("AMD_ESPI: In-band reset failed!\n");
+		}
+        }
 
-	return espi_send_cmd(amd_espi, &cmd);
+	return ret;
 }
 
 /*Set Slave config and cap reg vals*/
@@ -258,6 +325,7 @@ static u32 amd_espi_setOpFreqMode(struct amd_espi* amd_espi, u32 *slave_config,u
 
 static u32 amd_espi_GetConfig(struct amd_espi* amd_espi, u16 slave_reg_address, u32 *config)
 {
+	u32 ret;
 	struct espi_txcmd cmd = {
 		.hdr0 = {
 			.cmd_type = GET_CONFIGURATION,
@@ -267,8 +335,9 @@ static u32 amd_espi_GetConfig(struct amd_espi* amd_espi, u16 slave_reg_address,
 		},
 	};
 
-	if (espi_send_cmd(amd_espi, &cmd) != CB_SUCCESS) {
-		return CB_ERR;
+	ret = espi_send_cmd(amd_espi, &cmd);
+	if (ret != CB_SUCCESS) {
+		return ret;
 	}
 
 	*config = readl(ESPI_BASE + AMD_ESPI_DS_HEADER_REG1);
@@ -281,19 +350,22 @@ static int amd_espi_chenbl_info(struct amd_espi *amd_espi)
 	u32 chnl_config;
         u32 ret = 0;
 
-        if (amd_espi_GetConfig(amd_espi, ESPI_SLAVE_PERIPH_CFG, &chnl_config) != CB_ERR){
+        if (amd_espi_GetConfig(amd_espi, ESPI_SLAVE_PERIPH_CFG, &chnl_config) == CB_SUCCESS) {
                 if (chnl_config & ESPI_SLAVE_CHANNEL_ENABLE)
                         ret |= CHANNEL_MODE_PC;
         }
-        if (amd_espi_GetConfig(amd_espi, ESPI_SLAVE_VW_CFG, &chnl_config) != CB_ERR){
+        
+	if (amd_espi_GetConfig(amd_espi, ESPI_SLAVE_VW_CFG, &chnl_config) == CB_SUCCESS) {
                 if (chnl_config & ESPI_SLAVE_CHANNEL_ENABLE)
                         ret |= CHANNEL_MODE_VW;
-        }
-        if (amd_espi_GetConfig(amd_espi, ESPI_SLAVE_OOB_CFG, &chnl_config) != CB_ERR){
+        } 
+        
+	if (amd_espi_GetConfig(amd_espi, ESPI_SLAVE_OOB_CFG, &chnl_config) == CB_SUCCESS) { 
                 if (chnl_config & ESPI_SLAVE_CHANNEL_ENABLE)
                         ret |= CHANNEL_MODE_OOB;
         }
-        if (amd_espi_GetConfig(amd_espi, ESPI_SLAVE_FLASH_CFG, &chnl_config) != CB_ERR){
+        
+	if (amd_espi_GetConfig(amd_espi, ESPI_SLAVE_FLASH_CFG, &chnl_config) == CB_SUCCESS) {
                 if (chnl_config & ESPI_SLAVE_CHANNEL_ENABLE)
                         ret |= CHANNEL_MODE_FLASH;
         }
@@ -306,9 +378,10 @@ static int amd_espi_chenbl_info(struct amd_espi *amd_espi)
 
 static int amd_espi_Get_General_Config(struct amd_espi* amd_espi, u32 *config)
 {
-	if (amd_espi_GetConfig(amd_espi, ESPI_SLAVE_GENERAL_CAPS_CFG, config) != CB_SUCCESS) {
-		return CB_ERR;
-	}
+	u32 ret = amd_espi_GetConfig(amd_espi, ESPI_SLAVE_GENERAL_CAPS_CFG, config);
+	
+	if (ret != CB_SUCCESS)
+		return ret;
 
 	return CB_SUCCESS;
 }
@@ -330,16 +403,25 @@ static int amd_espi_SetConfig(struct amd_espi* amd_espi, u32 config, u16 slave_r
 	return espi_send_cmd(amd_espi, &cmd);
 }
 
-static int amd_espi_Set_General_Config(struct amd_espi* amd_espi, struct espi_device* dev)
+static int amd_espi_Set_General_Config(struct amd_espi *amd_espi, struct espi_device *dev)
 {
 	int status = 0;
 	u32 slave_config = 0;
 	u32 ctrlr_config = readl(ESPI_BASE + CNTRL_SLAVE0_CONFIG_REG);
 
-	if (amd_espi_Get_General_Config(amd_espi, &slave_config) != CB_SUCCESS) {
-		return CB_ERR;
+	status = amd_espi_Get_General_Config(amd_espi, &slave_config);
+	if (status != CB_SUCCESS) {
+		return status;
 	}
 
+	//Enable Alert mode by default
+	slave_config |= ESPI_SLAVE_ALERT_MODE_PIN;
+	ctrlr_config |= ESPI_ALERT_MODE;
+
+	//Enable CRC check by default
+	slave_config |= ESPI_SLAVE_CRC_ENABLE;
+	ctrlr_config |= ESPI_CRC_CHECKING_EN;
+
 	status = amd_espi_setIoMode(amd_espi, &slave_config, &ctrlr_config, dev->io_mode);
 	if (status != CB_SUCCESS)
 	{
@@ -358,7 +440,7 @@ static int amd_espi_Set_General_Config(struct amd_espi* amd_espi, struct espi_de
 
 	if (status != CB_SUCCESS)
 	{
-		return CB_ERR;
+		return status;
 	}
 
 	writel(ctrlr_config, (ESPI_BASE + CNTRL_SLAVE0_CONFIG_REG));
@@ -369,13 +451,15 @@ static u32 amd_espi_wait_channel_ready(struct amd_espi *amd_espi, u32 slave_reg_
 {
 	struct timer_list timer;
 	u32 config;
+	u32 ret;
 
 	timer_setup(&timer, timer_callback, 0);
 	timer.expires = jiffies + (HZ / 10);
 	add_timer(&timer);
 	do {
-		if (amd_espi_GetConfig(amd_espi, slave_reg_addr, &config) != CB_SUCCESS) {
-			return CB_ERR;
+		ret = amd_espi_GetConfig(amd_espi, slave_reg_addr, &config);
+		if (ret != CB_SUCCESS) {
+			return ret;
 		}
 		if (!!(config & ESPI_SLAVE_CHANNEL_READY))
 			return CB_SUCCESS;
@@ -400,9 +484,11 @@ static u32 amd_espi_set_channel_configuration(struct amd_espi *amd_espi,u32 slav
 		u32 slave_reg_addr,
 		u32 ctrlr_enable)
 {
-	if (amd_espi_SetConfig(amd_espi, slave_config, slave_reg_addr) != CB_SUCCESS) { //set slave's peripheral channel
+	u32 ret = amd_espi_SetConfig(amd_espi, slave_config, slave_reg_addr);
+
+	if (ret != CB_SUCCESS) { //set slave's peripheral channel
 		pr_err("AMD_ESPI:Channel: %s, set peripheral channel returing error\n", __func__);
-		return CB_ERR;
+		return ret;
 	}
 
 	if (!(slave_config & ESPI_SLAVE_CHANNEL_ENABLE)) //Channel ENABLE 
@@ -421,13 +507,15 @@ static u32 amd_espi_setup_periph_channel(struct amd_espi *amd_espi, u32 slave_ca
 {
 	struct espi_master *master = amd_espi->master;
 	u32 slave_config;
+	u32 ret;
+	
 	/* Peripheral channel requires BME bit to be set when enabling the channel. */
 	const u32 slave_en_mask =
 		ESPI_SLAVE_CHANNEL_ENABLE | ESPI_SLAVE_PERIPH_BUS_MASTER_ENABLE;
 
-
-	if (amd_espi_GetConfig(amd_espi, ESPI_SLAVE_PERIPH_CFG, &slave_config) != CB_SUCCESS) {
-		return CB_ERR;
+	ret = amd_espi_GetConfig(amd_espi, ESPI_SLAVE_PERIPH_CFG, &slave_config);
+	if (ret != CB_SUCCESS) {
+		return ret;
 	}
 
 	/* Check if PC is already enabled. If yes, return success */
@@ -461,6 +549,7 @@ static u32 amd_espi_setup_vw_channel(struct amd_espi *amd_espi, u32 slave_caps)
         struct espi_master *master = amd_espi->master;
         u32 slave_vw_caps;
         u32 slave_config;
+	u32 ret;
 
         /* check if master supports VW */
         if (!master->caps.vw_ch_en) {
@@ -473,41 +562,19 @@ static u32 amd_espi_setup_vw_channel(struct amd_espi *amd_espi, u32 slave_caps)
                 return CB_ERR;
         }
 
-        if (amd_espi_GetConfig(amd_espi, ESPI_SLAVE_VW_CFG, &slave_vw_caps) != CB_SUCCESS)
-                return CB_ERR;
+	ret = amd_espi_GetConfig(amd_espi, ESPI_SLAVE_VW_CFG, &slave_vw_caps);
+        if (ret != CB_SUCCESS)
+                return ret;
 
         slave_config = slave_vw_caps | ESPI_SLAVE_CHANNEL_ENABLE;
+	/* Check if VW is already enabled. If yes, return success */
+        if (slave_config & ESPI_SLAVE_CHANNEL_ENABLE){
+                return CB_SUCCESS;
+        }
         return amd_espi_set_channel_configuration(amd_espi, slave_config, ESPI_SLAVE_VW_CFG,
                                                   CHANNEL_MODE_VW);
 }
 
-static u32 amd_espi_setup_oob_channel(struct amd_espi *amd_espi, u32 slave_caps)
-{
-        struct espi_master *master = amd_espi->master;
-        u32 slave_config;
-
-        /* check if master supports OOB */
-        if (!master->caps.oob_ch_en) {
-                dev_err(amd_espi->dev, "Master does not support OOB\n");
-                return CB_ERR;
-        }
-
-        if (!(slave_caps & ESPI_SLAVE_OOB_CH_SUPP)) {
-                dev_err(amd_espi->dev, "eSPI slave doesn't support OOB channel!\n");
-                return CB_ERR;
-        }
-
-        if (amd_espi_GetConfig(amd_espi, ESPI_SLAVE_OOB_CFG, &slave_config) != CB_SUCCESS)
-                return CB_ERR;
-
-        slave_config |= ESPI_SLAVE_CHANNEL_ENABLE;
-
-        return amd_espi_set_channel_configuration(amd_espi, slave_config, ESPI_SLAVE_OOB_CFG,
-                                                  CHANNEL_MODE_OOB);
-}
-
-
-
 static void espi_get_io_mmio_decode_info(struct amd_espi *amd_espi, struct io_mmio_decode_config *config)
 {
 	config->io_mmio_dc_enable = readl(ESPI_BASE + ESPI_IO_MMIO_DECODE_EN_REG);
@@ -658,6 +725,7 @@ static int amd_espi_get_master_cap(struct amd_espi* amd_espi, struct espi_master
 	unsigned int info;
 
 	master_cap_reg = readl(ESPI_BASE + AMD_MASTER_CAP_REG);
+	
 	//Supported channels by master
 	if (master_cap_reg & BIT(0)) {
 		master->caps.flash_ch_en = 1;
@@ -728,7 +796,7 @@ static int amd_espi_get_master_cap(struct amd_espi* amd_espi, struct espi_master
 	master->caps.alert_mode = (master_cap_reg << 1) >> 31;
 
 	//CRC support by master
-	master->caps.crc_check_support = !((master_cap_reg >> 31) & 1);
+	master->caps.crc_check_support = (master_cap_reg >> 31) & 1;
 
 	return CB_SUCCESS;
 }
@@ -824,9 +892,17 @@ static int set_def_initial_config(struct espi_master *master, struct espi_device
 
 static int amd_espi_control_reg_init(struct amd_espi *amd_espi)
 {
-	u32 espi_version, global_ctrl_reg;
+	u32 espi_version, global_ctrl_reg, global_ctrl_reg1;
+	u32 misc_cntrl = 0;
+	u32 polarity_reg = 0;
+	//u32 recv_vw_reg = 0;
 	
-	//TODO: (1) WRT VW
+	//(1) clear any existing active bits
+//	recv_vw_reg = readl(ESPI_BASE + ESPI_RECEIVE_VW_REG);
+//	pr_info("recv_vw_reg before : %x\n",recv_vw_reg);
+//	writel((recv_vw_reg | 0xFFFF6F00), (ESPI_BASE + ESPI_RECEIVE_VW_REG));
+//	pr_info("recv_vw_reg after : %x\n",recv_vw_reg);
+
 	/*(2) Check master_cap_reg version*/
 	espi_version = readl(ESPI_BASE + AMD_MASTER_CAP_REG); 
 	espi_version = espi_version & (7 << 3);
@@ -844,13 +920,26 @@ static int amd_espi_control_reg_init(struct amd_espi *amd_espi)
 	writel(global_ctrl_reg, (ESPI_BASE + AMD_ESPI_GLOBAL_CNTRL_REG0));
 
 	/* (7,10)Set Slave0 Error Interrupt enable[19:0] and Command interrupt enable [31:24] */
-	writel(0, (ESPI_BASE + ESPI_SLAVE0_INT_EN));
-
-
-	/* (17)espi Bus Master Enable */ 
-	if( !(global_ctrl_reg & ESPI_BUS_MASTER_EN)){        
-		global_ctrl_reg = global_ctrl_reg | ESPI_BUS_MASTER_EN;
-		writel( global_ctrl_reg, (ESPI_BASE + AMD_ESPI_GLOBAL_CNTRL_REG1));
+	writel(ESPI_CRC_ERR, (ESPI_BASE + ESPI_SLAVE0_INT_EN));
+	global_ctrl_reg1 = readl(ESPI_BASE + AMD_ESPI_GLOBAL_CNTRL_REG1);
+	global_ctrl_reg1 |= (ESPI_RGCMD_INT(23) | ESPI_ERR_INT_SMI);
+	writel(global_ctrl_reg1, (ESPI_BASE + AMD_ESPI_GLOBAL_CNTRL_REG1));
+
+	/*(14) set the IRQ mask bit and polarity */
+	misc_cntrl = readl(ESPI_BASE + ESPI_VW_MISC_CNTRL_REG);
+	misc_cntrl |= ~(0xff);
+	writel(misc_cntrl,(ESPI_BASE + ESPI_VW_MISC_CNTRL_REG));
+
+	polarity_reg = readl(ESPI_BASE + ESPI_VW_POLARITY_REG);
+	writel((polarity_reg | 0xffffff), (ESPI_BASE + ESPI_VW_POLARITY_REG));
+
+	/*(15) enable to configure the VW index/data register*/
+	writel((misc_cntrl | 0xf), (ESPI_BASE + ESPI_VW_MISC_CNTRL_REG));
+
+	/* (16,17)espi Bus Master Enable and program the eSPI req not with vw req */ 
+	if( !(global_ctrl_reg1 & ESPI_BUS_MASTER_EN)){        
+		global_ctrl_reg1 = global_ctrl_reg1 | ESPI_BUS_MASTER_EN | BIT(21);
+		writel( global_ctrl_reg1, (ESPI_BASE + AMD_ESPI_GLOBAL_CNTRL_REG1));
 	}
 
 	return CB_SUCCESS;
@@ -861,6 +950,11 @@ static void espi_set_initial_config(struct amd_espi *amd_espi)
 	uint32_t espi_initial_mode = 0;
 	espi_initial_mode = readl(ESPI_BASE + CNTRL_SLAVE0_CONFIG_REG);
 	espi_initial_mode |= ((CNTRL_SLAVE0_OP_FREQ_16 << 25) | (IO_MODE_SINGLE << 28));
+
+	//Enable CRC and Alert mode by default
+	espi_initial_mode |= ESPI_ALERT_MODE; 
+	espi_initial_mode |= ESPI_CRC_CHECKING_EN;
+
 	writel(espi_initial_mode, (ESPI_BASE + CNTRL_SLAVE0_CONFIG_REG));
 }
 
@@ -869,15 +963,15 @@ static int amd_espi_init_slave(struct amd_espi *amd_espi, struct espi_device *es
 	struct espi_master *master = amd_espi->master;
 	int ret;
 	u32 slave_caps = 0;
+	u32 global_ctrl_reg = 0;
 
-/*	espi_set_initial_config(amd_espi);
+	espi_set_initial_config(amd_espi);
 	if (amd_espi_inband_reset(amd_espi) != CB_SUCCESS) {
 		pr_err("AMD_ESPI: In-band reset failed!\n");
 		return CB_ERR;
-	}*/
-	espi_set_initial_config(amd_espi);
-	ret = amd_espi_get_master_cap(amd_espi, master);
+	}
 
+	ret = amd_espi_get_master_cap(amd_espi, master);
 	if (ret != CB_SUCCESS) {
 		pr_err("AMD_ESPI: %s, master capability returns error\n", __func__);
 		return -ENOTSUPP;
@@ -889,11 +983,17 @@ static int amd_espi_init_slave(struct amd_espi *amd_espi, struct espi_device *es
 		return -ENOTSUPP;
 	}
 
-	if (amd_espi_Set_General_Config(amd_espi, espi_dev) != CB_SUCCESS)
-		return CB_ERR;
+	ret = amd_espi_Set_General_Config(amd_espi, espi_dev);
+	if (ret != CB_SUCCESS)
+		return ret;
 
-	if (amd_espi_Get_General_Config(amd_espi, &slave_caps) != CB_SUCCESS)
-		return CB_ERR;
+	ret = amd_espi_Get_General_Config(amd_espi, &slave_caps);
+	if (ret != CB_SUCCESS)
+		return ret;
+
+	global_ctrl_reg = readl(ESPI_BASE + AMD_ESPI_GLOBAL_CNTRL_REG1);
+	global_ctrl_reg |= BIT(20);
+	writel(global_ctrl_reg, (ESPI_BASE + AMD_ESPI_GLOBAL_CNTRL_REG1));
 
 	if (amd_espi_setup_periph_channel(amd_espi, slave_caps) != CB_SUCCESS){
 		pr_err("AMD_ESPI: %s: amd_espi_setup_periph_channel failed\n", __func__);
@@ -1164,6 +1264,7 @@ static long amd_espi_ioctl(struct file *filp, unsigned int cmd, unsigned long ar
 	struct io_mmio_decode_config *io_dc_config = NULL;
 	struct periph_mem_rw *mem_data = NULL;
 	u32 ret;
+	u32 ret_val;
 	u32 slave_config;
 	u32 ctrlr_config;
 	u32 io_range = 0;
@@ -1218,12 +1319,14 @@ static long amd_espi_ioctl(struct file *filp, unsigned int cmd, unsigned long ar
 			else if(config->op_freq == SLAVE_OP_FREQ_66)
 				dev->op_freq = SLAVE_OP_FREQ_66;
 
-			if (amd_espi_Set_General_Config(amd_espi, dev) != CB_SUCCESS)
-				return CB_ERR;
+			ret_val = amd_espi_Set_General_Config(amd_espi, dev);
+			if (ret_val != CB_SUCCESS)
+				return ret_val;
 
 			/* Channel Config */
-			if ((amd_espi_Get_General_Config(amd_espi, &slave_config)) != CB_SUCCESS)
-				return CB_ERR;
+			ret_val = amd_espi_Get_General_Config(amd_espi, &slave_config);
+			if (ret_val != CB_SUCCESS)
+				return ret_val;
 
 			if (config->channel_mode == CHANNEL_MODE_PC){
                                 ret = amd_espi_setup_periph_channel(amd_espi, slave_config);
@@ -1244,18 +1347,6 @@ static long amd_espi_ioctl(struct file *filp, unsigned int cmd, unsigned long ar
                                         "amd_espi_setup_VW_channel failed\n");
                                         return CB_ERR;
                                 }
-                        } else if(config->channel_mode == CHANNEL_MODE_OOB) {
-                                ret = amd_espi_Get_General_Config(amd_espi, &slave_config);
-                                if (ret) {
-                                        dev_err(amd_espi->dev, "amd_espi_Get_General_Config for channel failed\n");
-                                        return CB_ERR;
-                                }
-
-                                ret = amd_espi_setup_oob_channel(amd_espi, slave_config);
-                                if (ret) {
-                                        dev_err(amd_espi->dev, "amd_espi_setup_VW_channel failed\n");
-                                        return CB_ERR;
-                                }
                         } else {
                                 dev_err(amd_espi->dev, "Opted channel not suported\n");
                                 return CB_ERR;
@@ -1264,8 +1355,9 @@ static long amd_espi_ioctl(struct file *filp, unsigned int cmd, unsigned long ar
 
 		case ESPI_GET_CONFIG:
 
-			if(amd_espi_Get_General_Config(amd_espi, &ret) == CB_ERR)
-				return CB_ERR;
+			ret_val = amd_espi_Get_General_Config(amd_espi, &ret);
+			if(ret_val != CB_SUCCESS)
+				return ret_val;
 
 			io_mode = (ret & (0x3 << ESPI_SLAVE_IO_MODE_SEL_SHIFT)) >> 26;
 			switch (io_mode) {
@@ -1340,9 +1432,9 @@ static long amd_espi_ioctl(struct file *filp, unsigned int cmd, unsigned long ar
 			}
 			ctrlr_config = readl(ESPI_BASE + CNTRL_SLAVE0_CONFIG_REG);
 
-
-			if (amd_espi_Get_General_Config(amd_espi, &slave_config) != CB_SUCCESS) {
-				return CB_ERR;
+			ret_val = amd_espi_Get_General_Config(amd_espi, &slave_config);
+			if (ret_val != CB_SUCCESS) {
+				return ret_val;
 			}
 
 			ret = amd_espi_setIoMode(amd_espi, &slave_config, &ctrlr_config, config->io_mode);
@@ -1355,7 +1447,7 @@ static long amd_espi_ioctl(struct file *filp, unsigned int cmd, unsigned long ar
 			ret = amd_espi_SetConfig(amd_espi, slave_config, ESPI_SLAVE_GENERAL_CAPS_CFG);
 			if (ret != CB_SUCCESS) {
 				pr_err("AMD_ESPI: Set IO mode failed\n");
-				return CB_ERR;
+				return ret;
 			}
 			writel(ctrlr_config, (ESPI_BASE + CNTRL_SLAVE0_CONFIG_REG));
 			break;
@@ -1367,9 +1459,10 @@ static long amd_espi_ioctl(struct file *filp, unsigned int cmd, unsigned long ar
 
 			switch(config->channel_mode){
 				case CHANNEL_MODE_PC :
-					if ((amd_espi_Get_General_Config(amd_espi, &slave_config)) != CB_SUCCESS){
+					ret_val = amd_espi_Get_General_Config(amd_espi, &slave_config);
+					if (ret_val != CB_SUCCESS){
 						pr_err("AMD_ESPI: amd_espi_Get_General_Config for channel failed\n");
-						return CB_ERR;
+						return ret_val;
 					}
 
 					if ((amd_espi_setup_periph_channel(amd_espi, slave_config)) != CB_SUCCESS) {
@@ -1379,9 +1472,10 @@ static long amd_espi_ioctl(struct file *filp, unsigned int cmd, unsigned long ar
 
 					break;
 				case CHANNEL_MODE_VW:
-					if ((amd_espi_Get_General_Config(amd_espi, &slave_config)) != CB_SUCCESS){
+					ret_val = amd_espi_Get_General_Config(amd_espi, &slave_config);
+					if (ret_val != CB_SUCCESS){
                                                 pr_err("AMD_ESPI: amd_espi_Get_General_Config for channel failed\n");
-                                                return CB_ERR;
+                                                return ret_val;
                                         }
 
                                         if (amd_espi_setup_vw_channel(amd_espi, slave_config) != CB_SUCCESS){
@@ -1390,18 +1484,10 @@ static long amd_espi_ioctl(struct file *filp, unsigned int cmd, unsigned long ar
                                         }
 					break;
 				case CHANNEL_MODE_OOB:
-					if ((amd_espi_Get_General_Config(amd_espi, &slave_config)) != CB_SUCCESS){
-                                                pr_err("AMD_ESPI: amd_espi_Get_General_Config for channel failed\n");
-                                                return CB_ERR;
-                                        }
-
-                                        if (amd_espi_setup_oob_channel(amd_espi, slave_config) != CB_SUCCESS){
-                                                pr_err("AMD_ESPI: %s: amd_espi_setup_VW_channel failed\n", __func__);
-                                                return CB_ERR;
-                                        }
+					pr_err("AMD_ESPI: OOB channel not supported\n");
 					break;
 				case CHANNEL_MODE_FLASH:
-					pr_err("AMD_ESPI: FLASH not supported\n");
+					pr_err("AMD_ESPI: FLASH Channel not supported\n");
 					break;
 				default:
 					pr_err("AMD_ESPI:Channel: not supported\n");
@@ -1416,8 +1502,9 @@ static long amd_espi_ioctl(struct file *filp, unsigned int cmd, unsigned long ar
 			}
 			ctrlr_config = readl(ESPI_BASE + CNTRL_SLAVE0_CONFIG_REG);
 
-			if (amd_espi_Get_General_Config(amd_espi, &slave_config) != CB_SUCCESS) {
-				return CB_ERR;
+			ret_val = amd_espi_Get_General_Config(amd_espi, &slave_config);
+			if (ret_val != CB_SUCCESS) {
+				return ret_val;
 			}
 
 
@@ -1431,7 +1518,7 @@ static long amd_espi_ioctl(struct file *filp, unsigned int cmd, unsigned long ar
 			ret = amd_espi_SetConfig(amd_espi, slave_config,ESPI_SLAVE_GENERAL_CAPS_CFG);
 			if (ret != CB_SUCCESS) {
 				pr_err("AMD_ESPI: Set OP Freq failed\n");
-				return CB_ERR;
+				return ret;
 			}
 			writel(ctrlr_config, (ESPI_BASE + CNTRL_SLAVE0_CONFIG_REG));
 
diff --git a/drivers/spi/espi-err.h b/drivers/spi/espi-err.h
new file mode 100644
index 000000000..398079258
--- /dev/null
+++ b/drivers/spi/espi-err.h
@@ -0,0 +1,55 @@
+/* ERROR CODE - BIT POSITION */
+#define POS_BUS_TIMING          0
+#define POS_BUS_WAIT_STATE      1
+#define POS_CRC                 2
+#define POS_NO_RESP             4
+#define POS_FATAL_ERR           5
+#define POS_NON_FATAL_ERR       6
+#define POS_INVALID_RESP_CODE   7
+#define POS_INVALID_CYCLE_TYPE  8
+#define POS_UNSUCCESS_CPL_RECV  9
+#define POS_ILLEGAL_RESP_TAG    10
+#define POS_ILLEGAL_RESP_LEN    11
+#define POS_OOB_DATA_LEN        12
+#define POS_PC_MSG_DATA         13
+#define POS_FLASH_DATA_LEN      14
+#define POS_PROTOCOL_ERR        15
+
+#define ESPI_BUS_TIME_ERR               BIT(POS_BUS_TIMING)
+#define ESPI_BUS_WAIT_STATE_ERR         BIT(POS_BUS_WAIT_STATE)
+#define ESPI_CRC_ERR                    BIT(POS_CRC)
+#define ESPI_NO_RESP_ERR                BIT(POS_NO_RESP)
+#define ESPI_FATAL_ERR                  BIT(POS_FATAL_ERR)
+#define ESPI_NON_FATAL_ERR              BIT(POS_NON_FATAL_ERR)
+#define ESPI_INVALID_RESP_CODE_ERR      BIT(POS_INVALID_RESP_CODE)
+#define ESPI_INVALID_CYCLE_TYPE_ERR     BIT(POS_INVALID_CYCLE_TYPE)
+#define ESPI_UNSUCCESS_CPL_RECV         BIT(POS_UNSUCCESS_CPL_RECV)
+#define ESPI_ILLEGAL_RESP_TAG_ERR       BIT(POS_ILLEGAL_RESP_TAG)
+#define ESPI_ILLEGAL_RESP_LEN           BIT(POS_ILLEGAL_RESP_LEN)
+#define ESPI_OOB_DATA_LEN_ERR           BIT(POS_OOB_DATA_LEN)
+#define ESPI_PC_MSG_DATA_LEN_ERR        BIT(POS_PC_MSG_DATA)
+#define ESPI_FLASH_DATA_LEN_ERR         BIT(POS_FLASH_DATA_LEN)
+#define ESPI_PROTOCOL_ERR               BIT(POS_PROTOCOL_ERR)
+
+#define ESPI_DOWNSTREAM_CMD_ERR         BIT(31)
+
+/* Human-readable error strings */
+static char *espi_error_codes[] = {
+        "ERR 00: eSPI BUS TIMING ERROR",
+        "ERR 01: eSPI WAIT STATE TIMER TIMEOUT",
+        "ERR 02: eSPI CRC ERROR",
+        "",
+        "ERR 04: NO RESPONSE FROM SLAVE",
+        "ERR 05: FATAL_ERROR RESPONSE FROM SLAVE",
+        "ERR 06: NON_FATAL_ERROR RESPONSE FROM SLAVE",
+        "ERR 07: INVALID RESPONSE CODE RECEIVED",
+        "ERR 08: INVALID CYCLE TYPE RECEIVED",
+        "ERR 09: UNSUCCESSFUL COMPLETION PACKET",
+        "ERR 10: ILLEGAL RESPONSE TAG",
+        "ERR 11: ILLEGAL RESPONSE LENGTH",
+        "ERR 12: OOB PACKET DATA LENGTH ERROR",
+        "ERR 13: PC MESSAGE DATA LENGTH ERROR",
+        "ERR 14: FLASH PACKET DATA LENGTH ERROR",
+        "ERR 15: PROTOCOL ERROR",
+};
+
diff --git a/drivers/spi/espi.h b/drivers/spi/espi.h
index 15ea3b5bc..649b7f5f8 100644
--- a/drivers/spi/espi.h
+++ b/drivers/spi/espi.h
@@ -24,9 +24,17 @@
 #define ESPI_TARGET_MMIO_REG5                0x64       //40+70*N+24
 
 #define CNTRL_SLAVE0_CONFIG_REG      0x68       //0x40+70*N+28
+#define  ESPI_CRC_CHECKING_EN			(1 << 31)
+#define  ESPI_ALERT_MODE			    (1 << 30)
 #define AMD_INT_ENABLE               0x6C       //40+70*N+2C
 #define AMD_INT_STATUS               0x70       //40+70*N+30
 
+#define ESPI_RECEIVE_VW_REG           0x9C      //40+70*N+5C
+#define ESPI_RECEIVE_VW_DATA_REG      0xA0     //40+70*N+60
+#define ESPI_RECEIVE_VW_INDEX_REG     0xA4     //40+70*N+64
+#define ESPI_VW_MISC_CNTRL_REG        0xA8     //40+70*N+68
+#define ESPI_VW_POLARITY_REG          0xAC     //40+70*N+6C
+
 /*Slave Status*/
 #define ESPI_SLAVE0_INT_EN           0x6c
 #define ESPI_SLAVE0_INT_STS          0x70
@@ -37,7 +45,7 @@
 #define ESPI_STATUS_CRC_ERR          (1 << 2)
 #define ESPI_STATUS_WAIT_TIMEOUT     (1 << 1)
 #define ESPI_STATUS_BUS_ERROR	     (1 << 0)
-#define ESPI_PC_MSG_RCVD		 (1 << 29)
+#define ESPI_PC_MSG_RCVD	     (1 << 29)
 
 /*Master capability and control Reg*/
 #define AMD_MASTER_CAP_REG           0x2C
diff --git a/drivers/spi/espi_slave.h b/drivers/spi/espi_slave.h
index e8d737cd4..1a02ef93b 100644
--- a/drivers/spi/espi_slave.h
+++ b/drivers/spi/espi_slave.h
@@ -1,5 +1,11 @@
 #define ESPI_SLAVE_GENERAL_CAPS_CFG				0x08
 
+#define  ESPI_SLAVE_CRC_ENABLE				(1 << 31)
+#define  ESPI_SLAVE_CRC_DISABLE				(0 << 31)
+
+#define  ESPI_SLAVE_ALERT_MODE_PIN			(1 << 28)
+#define  ESPI_SLAVE_ALERT_MODE_IO1			(0 << 28)
+
 #define  ESPI_SLAVE_IO_MODE_SEL_SHIFT			26
 #define  ESPI_SLAVE_IO_MODE_SEL_MASK			~(0x3 << ESPI_SLAVE_IO_MODE_SEL_SHIFT)
 #define  ESPI_SLAVE_IO_MODE_SEL_VAL(x)			((x) << ESPI_SLAVE_IO_MODE_SEL_SHIFT)
-- 
2.34.1


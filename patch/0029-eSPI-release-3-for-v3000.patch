From de01805852144d5ddb6966bf8710d17fe1e02b09 Mon Sep 17 00:00:00 2001
From: Akshata MukundShetty <akshata.mukundshetty@amd.com>
Date: Thu, 29 Feb 2024 20:49:16 +0530
Subject: [PATCH 29/33] eSPI release-3 for v3000

Supported features:
1. GET VW support for virtual wire interrupt events.
2. Put Virutal wire command.

Co-developed-by: Krishnamoorthi M <krishnamoorthi.m@amd.com>
Signed-off-by: Krishnamoorthi M <krishnamoorthi.m@amd.com>
Signed-off-by: Akshata MukundShetty <akshata.mukundshetty@amd.com>
Change-Id: Ie9cd2eb764121bdad1ca5d9b04083a65256b19da
---
 drivers/spi/espi-amd.c      | 1704 ++++++++++++++++++++++++-----------
 drivers/spi/espi-err.h      |   39 +-
 drivers/spi/espi.h          |  282 ++++--
 drivers/spi/espi_bmc_uart.h |  121 +++
 drivers/spi/espi_slave.h    |   13 +-
 5 files changed, 1509 insertions(+), 650 deletions(-)
 create mode 100644 drivers/spi/espi_bmc_uart.h

diff --git a/drivers/spi/espi-amd.c b/drivers/spi/espi-amd.c
index d4cc31073..7780438f4 100644
--- a/drivers/spi/espi-amd.c
+++ b/drivers/spi/espi-amd.c
@@ -15,15 +15,17 @@
 #include <linux/timer.h>
 #include <asm/uaccess.h>
 #include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/iopoll.h>
 #include "espi.h"
 #include "espi_slave.h"
 #include "espi-err.h"
+#include "espi_bmc_uart.h"
 
 #define ESPI_DEV_MINORS		0
 #define N_ESPI_MINORS           1
 
 #define ESPI_CH_READY_TIMEOUT_US		10000
-
 #define ESPI_BASE	((u8 __iomem *)amd_espi->io_remap_addr)
 
 /*
@@ -37,20 +39,22 @@ enum amd_espi_versions {
 	AMD_ESPI_V1 = 1,     /* AMDI0070 */
 };
 
+/* Default channel, IO mode, Frequency */
 int espi_channel = 0;	//PC channel
 int espi_io_mode = 0;	//Single IO MODE
 int espi_op_freq = 16;	//16MHz
 
 struct amd_espi {
-	void __iomem *io_remap_addr;
-	unsigned long io_base_addr;
-	enum amd_espi_versions version;
-	struct device          *dev;
+	void __iomem		*io_remap_addr;
+	unsigned long		io_base_addr;
+	enum amd_espi_versions	version;
+	struct device		*dev;
 	struct espi_master	*master;
-	dev_t                  dev_minor;
-	spinlock_t             espi_lock;
-	struct list_head       device_entry;
-	unsigned		   users;
+	dev_t			dev_minor;
+	spinlock_t		espi_lock;
+	struct list_head	device_entry;
+	unsigned int		users;
+	unsigned int		irq;
 };
 
 static LIST_HEAD(device_list);
@@ -58,34 +62,16 @@ static DEFINE_MUTEX(device_list_lock);
 
 static struct class *amd_espi_dev_class;
 static struct cdev cdev;
-dev_t dev_minor;
 
-static int espi_send_cmd(struct amd_espi *amd_espi, struct espi_txcmd *cmd);
+static int amd_espi_inband_reset(struct amd_espi *amd_espi);
 static void espi_set_initial_config(struct amd_espi *amd_espi);
+void bmc_uart_enable_ioctl(void);
 
-void timer_callback(struct timer_list *timer)
+static void timer_callback(struct timer_list *timer)
 {
 	pr_info("AMD_ESPI: timer call back\n");
 }
 
-static int espi_ready_wait(struct amd_espi *amd_espi)
-{
-	union espi_txhdr0 hdr0;
-	unsigned int iter = 0;
-
-	while (iter < 8)
-	{
-		hdr0.val = readl(ESPI_BASE + AMD_ESPI_DS_HEADER_REG0);
-		if (!hdr0.cmd_status) {
-			return CB_SUCCESS;
-		}
-		msleep(20);
-		iter++;
-	}
-
-	return CB_ERR;
-}
-
 static void espi_clear_status(struct amd_espi *amd_espi)
 {
 	uint32_t status = readl(ESPI_BASE + ESPI_SLAVE0_INT_STS);
@@ -93,158 +79,242 @@ static void espi_clear_status(struct amd_espi *amd_espi)
 		writel(status, (ESPI_BASE + ESPI_SLAVE0_INT_STS));
 }
 
-static int espi_poll_status(struct amd_espi *amd_espi, u32 *status)
+static int check_error_status(u32 status)
 {
-	int iter = 0;
+        u32 ret = 0;
 
-	while (iter < 8)
-	{
-		*status = readl(ESPI_BASE + ESPI_SLAVE0_INT_STS);
-		if (*status) {
-			return CB_SUCCESS;
-		}
-		msleep(20);
-		iter++;
-	}
+        if (!(status & ESPI_STATUS_DNCMD_COMPLETE)) { //did not complete downstream
+                ret =  ESPI_DOWNSTREAM_CMD_ERR;
+                pr_err("AMD_ESPI: eSPI downstream command completion failure\n");
+        } else if (status & ESPI_BUS_TIME_ERR) {
+                ret = ESPI_BUS_TIME_ERR;
+                pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_BUS_TIMING]);
+        } else if (status & ESPI_BUS_WAIT_STATE_ERR) {
+                ret = ESPI_BUS_WAIT_STATE_ERR;
+                pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_BUS_WAIT_STATE]);
+        } else if (status & ESPI_CRC_ERR) {
+                ret = ESPI_CRC_ERR;
+                pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_CRC]);
+        } else if (status & ESPI_NO_RESP_ERR) {
+                ret = ESPI_NO_RESP_ERR;
+                pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_NO_RESP]);
+        } else if (status & ESPI_FATAL_ERR) {
+                ret = ESPI_FATAL_ERR;
+                pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_FATAL_ERR]);
+        } else if (status & ESPI_NON_FATAL_ERR) {
+                ret = ESPI_NON_FATAL_ERR;
+                pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_NON_FATAL_ERR]);
+        } else if (status & ESPI_INVALID_RESP_CODE_ERR) {
+                ret = ESPI_INVALID_RESP_CODE_ERR;
+                pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_INVALID_RESP_CODE]);
+        } else if (status & ESPI_INVALID_CYCLE_TYPE_ERR) {
+                ret = ESPI_INVALID_CYCLE_TYPE_ERR;
+                pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_INVALID_CYCLE_TYPE]);
+        } else if (status & ESPI_UNSUCCESS_CPL_RECV) {
+                ret = ESPI_UNSUCCESS_CPL_RECV;
+                pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_UNSUCCESS_CPL_RECV]);
+        } else if (status & ESPI_ILLEGAL_RESP_TAG_ERR) {
+                ret = ESPI_ILLEGAL_RESP_TAG_ERR;
+                pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_ILLEGAL_RESP_TAG]);
+        } else if (status & ESPI_ILLEGAL_RESP_LEN) {
+                ret = ESPI_ILLEGAL_RESP_LEN;
+                pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_ILLEGAL_RESP_LEN]);
+        } else if (status & ESPI_OOB_DATA_LEN_ERR) {
+                ret = ESPI_OOB_DATA_LEN_ERR;
+                pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_OOB_DATA_LEN]);
+        } else if (status & ESPI_PC_MSG_DATA_LEN_ERR) {
+                ret = ESPI_PC_MSG_DATA_LEN_ERR;
+                pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_PC_MSG_DATA]);
+        } else if (status & ESPI_FLASH_DATA_LEN_ERR) {
+                ret = ESPI_FLASH_DATA_LEN_ERR;
+                pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_FLASH_DATA_LEN]);
+        } else if (status & ESPI_PROTOCOL_ERR) {
+                ret = ESPI_PROTOCOL_ERR;
+                pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_PROTOCOL_ERR]);
+        } else
+                ret = CB_SUCCESS;
 
-	return CB_ERR;
+        return ret;
 }
 
-static int check_error_status(u32 status)
+static int espi_alloc_cmd_data(struct espi_txcmd *cmd)
 {
-	u32 ret = 0;
-
-	if (!(status & ESPI_STATUS_DNCMD_COMPLETE)) { //did not complete downstream
-		ret =  ESPI_DOWNSTREAM_CMD_ERR;
-		pr_err("AMD_ESPI: eSPI downstream command completion failure\n");
-	} else if (status & ESPI_BUS_TIME_ERR) {
-		ret = ESPI_BUS_TIME_ERR;
-		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_BUS_TIMING]);
-	} else if (status & ESPI_BUS_WAIT_STATE_ERR) {
-		ret = ESPI_BUS_WAIT_STATE_ERR;
-		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_BUS_WAIT_STATE]);
-	} else if (status & ESPI_CRC_ERR) {
-		ret = ESPI_CRC_ERR;
-		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_CRC]);
-	} else if (status & ESPI_NO_RESP_ERR) {
-		ret = ESPI_NO_RESP_ERR;
-		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_NO_RESP]);
-	} else if (status & ESPI_FATAL_ERR) {
-		ret = ESPI_FATAL_ERR;
-		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_FATAL_ERR]);
-	} else if (status & ESPI_NON_FATAL_ERR) {
-		ret = ESPI_NON_FATAL_ERR;
-		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_NON_FATAL_ERR]);
-	} else if (status & ESPI_INVALID_RESP_CODE_ERR) {
-		ret = ESPI_INVALID_RESP_CODE_ERR;
-		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_INVALID_RESP_CODE]);
-	} else if (status & ESPI_INVALID_CYCLE_TYPE_ERR) {
-		ret = ESPI_INVALID_CYCLE_TYPE_ERR;
-		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_INVALID_CYCLE_TYPE]);
-	} else if (status & ESPI_UNSUCCESS_CPL_RECV) {
-		ret = ESPI_UNSUCCESS_CPL_RECV;
-		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_UNSUCCESS_CPL_RECV]);
-	} else if (status & ESPI_ILLEGAL_RESP_TAG_ERR) {
-		ret = ESPI_ILLEGAL_RESP_TAG_ERR;
-		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_ILLEGAL_RESP_TAG]);
-	} else if (status & ESPI_ILLEGAL_RESP_LEN) {
-		ret = ESPI_ILLEGAL_RESP_LEN;
-		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_ILLEGAL_RESP_LEN]);
-	} else if (status & ESPI_OOB_DATA_LEN_ERR) {
-		ret = ESPI_OOB_DATA_LEN_ERR;
-		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_OOB_DATA_LEN]);
-	} else if (status & ESPI_PC_MSG_DATA_LEN_ERR) {
-		ret = ESPI_PC_MSG_DATA_LEN_ERR;
-		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_PC_MSG_DATA]);
-	} else if (status & ESPI_FLASH_DATA_LEN_ERR) {
-		ret = ESPI_FLASH_DATA_LEN_ERR;
-		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_FLASH_DATA_LEN]);
-	} else if (status & ESPI_PROTOCOL_ERR) {
-		ret = ESPI_PROTOCOL_ERR;
-		pr_err("AMD_ESPI: %s\n", espi_error_codes[POS_PROTOCOL_ERR]);
-	} else
-		ret = CB_SUCCESS;
+	u32 size = 0;
+	
+	switch(cmd->hdr0.cmd_type)
+	{
+		case SET_CONFIGURATION:
+		case GET_CONFIGURATION:
+		case IN_BAND_RESET:
+			size = 1;
+			break;
+		case PERIPHERAL_CHNL:
+			break;
+		case VW_CHNL:
+			size = (cmd->hdr0.hdata0 + 1) * sizeof(struct vw_data);
+			break;
+		default:
+			break;
+	}
 
-	return ret;
+	if (!size) {
+		return -ENOTSUPP;
+	}
+	
+	size = DATA_SIZE_ROUNDOFF_4(size);
+	cmd->data = kzalloc(size, GFP_KERNEL);
+	
+	if (!cmd->data) 
+	{
+		return -ENOMEM;
+	}
+	memset(cmd->data, 0, size);
+	
+	return CB_SUCCESS;
 }
 
-static int amd_espi_inband_reset(struct amd_espi *amd_espi)
+static void espi_send_downstream_data(struct amd_espi *amd_espi, struct espi_txcmd *cmd)
 {
-	u32 ret;
-	struct espi_txcmd cmd = {
-		.hdr0 = {
-			.cmd_type = IN_BAND_RESET,
-			.cmd_status = 1,
-		},
-	};
+	union espi_txdata *data = cmd->data;
 
-	ret = espi_send_cmd(amd_espi, &cmd);
-	if(ret != CB_SUCCESS)
-		return ret;
-	else
-		espi_set_initial_config(amd_espi);
-	return CB_SUCCESS;
+	//Write first 4 bytes of data - common for all commands
+	writel(data->val, (ESPI_BASE + AMD_ESPI_DS_DATA_REG0));
+	data++;
+
+	//Based on the command type write remaining data
+	switch(cmd->hdr0.cmd_type)
+	{
+		case SET_CONFIGURATION:
+		case GET_CONFIGURATION:
+		case IN_BAND_RESET:
+		case PERIPHERAL_CHNL:
+			break;
+		case VW_CHNL:
+		{
+			u32 data_len = cmd->hdr0.hdata0 * sizeof(struct vw_data);
+
+			data_len = DATA_SIZE_ROUNDOFF_4(data_len);
+			if(data_len >= 4)
+			{
+				int remaining_len = data_len - 4;
+				while (remaining_len)
+				{
+					writel(data->val, (ESPI_BASE + AMD_ESPI_DS_DATA_REG0));
+					remaining_len -= 4;
+					data++;
+				}
+			}
+		}
+		default:
+			break;
+	}
 }
 
 static int espi_send_cmd(struct amd_espi *amd_espi, struct espi_txcmd *cmd)
 {
-	u32 status;
-	u32 ret = 0;
+	u32 status, ret, val;
 
-	if (espi_ready_wait(amd_espi) != CB_SUCCESS)
+	/* Wait until HW is ready to send the command */	
+	ret = readx_poll_timeout(ioread32, ESPI_BASE + AMD_ESPI_DS_HEADER_REG0,
+                                val, (val & BIT(3)) == 0, ESPI_MSG_DELAY_MIN_US,
+                                ESPI_RESP_MAX_TIMEOUT);
+
+	if (ret)
 	{
 		pr_err("AMD_ESPI: %s, espi_ready_wait failed, before write\n", __func__);
 		pr_err("AMD_ESPI: eSPI cmd0-cmd2: %08x %08x %08x data: %08x.\n",
-				cmd->hdr0.val, cmd->hdr1.val, cmd->hdr2.val, cmd->data.val);
-		pr_err("AMD_ESPI: Error: eSPI was not ready to accept a command\n");
+				cmd->hdr0.val, cmd->hdr1.val, cmd->hdr2.val, cmd->data->val);
+		pr_err("AMD_ESPI: Error: eSPI was not ready to accept a command (Status = 0x%x)\n", status);
 		return ESPI_DOWNSTREAM_CMD_ERR;
 	}
 	espi_clear_status(amd_espi);
 
 	writel(cmd->hdr1.val, (ESPI_BASE + AMD_ESPI_DS_HEADER_REG1));
 	writel(cmd->hdr2.val, (ESPI_BASE + AMD_ESPI_DS_HEADER_REG2));
-	writel(cmd->data.val, (ESPI_BASE + AMD_ESPI_DS_DATA_REG0));
+
+	espi_send_downstream_data(amd_espi, cmd);
 
 	writel(cmd->hdr0.val, (ESPI_BASE + AMD_ESPI_DS_HEADER_REG0));
+	
+	/* wait until HW successfully sent the packet*/
+	ret = readx_poll_timeout(ioread32, ESPI_BASE + AMD_ESPI_DS_HEADER_REG0,
+				val, (val & BIT(3)) == 0, ESPI_MSG_DELAY_MIN_US,
+				ESPI_RESP_MAX_TIMEOUT);
 
-	if (espi_ready_wait(amd_espi) != CB_SUCCESS){
+	if (ret) {
 		pr_err("AMD_ESPI: %s, espi_ready_wait failed, after write\n", __func__);
 		pr_err("AMD_ESPI: eSPI cmd0-cmd2: %08x %08x %08x data: %08x.\n",
-				cmd->hdr0.val, cmd->hdr1.val, cmd->hdr2.val, cmd->data.val);
-		pr_err("AMD_ESPI: Error: eSPI timed out waiting for command to complete\n");
+				cmd->hdr0.val, cmd->hdr1.val, cmd->hdr2.val, cmd->data->val);
+		pr_err("AMD_ESPI: Error: eSPI timed out waiting for command to complete (Status = 0x%x)\n", status);
 		return ESPI_DOWNSTREAM_CMD_ERR;
 	}
 
-	if (espi_poll_status(amd_espi, &status) != CB_SUCCESS){
+
+	/* wait until DS command completion interrupt received */
+	// TODO: should we check only downstream complete error status?
+	ret = readx_poll_timeout(ioread32, ESPI_BASE + ESPI_SLAVE0_INT_STS,
+                                status,  status != 0, ESPI_MSG_DELAY_MIN_US,
+				ESPI_RESP_MAX_TIMEOUT);
+
+	if (ret) {
 		pr_err("AMD_ESPI: %s, espi_poll_status failed, after write\n", __func__);
 		pr_err("AMD_ESPI: eSPI cmd0-cmd2: %08x %08x %08x data: %08x.\n",
-				cmd->hdr0.val, cmd->hdr1.val, cmd->hdr2.val, cmd->data.val);
+				cmd->hdr0.val, cmd->hdr1.val, cmd->hdr2.val, cmd->data->val);
 		pr_err("AMD_ESPI: Error: eSPI poll status failed (Status = 0x%x)\n", status);
 		return CB_ERR;
 	}
 
 	ret = check_error_status(status);
-	if (ret != CB_SUCCESS) {
-		pr_err("AMD_ESPI: eSPI command packet:\n"
-				"Header-0: %08x\nHeader-1: %08x\n"
-				"Header-2: %08x\nData: %08x\n",	
-				cmd->hdr0.val, cmd->hdr1.val, cmd->hdr2.val, cmd->data.val);	
+        if (ret != CB_SUCCESS) {
+                pr_err("AMD_ESPI: eSPI command packet:\n"
+                                "Header-0: %08x\nHeader-1: %08x\n"
+                                "Header-2: %08x\nData: %08x\n",
+                                cmd->hdr0.val, cmd->hdr1.val, cmd->hdr2.val, cmd->data->val);
 
-		pr_err("AMD_ESPI: eSPI status register bits set (Status = 0x%x)\n", status);
-	}
+                pr_err("AMD_ESPI: eSPI status register bits set (Status = 0x%x)\n", status);
+        }
 
-	if (ret == ESPI_NO_RESP_ERR) {
-		pr_info("AMD_ESPI: Triggering Inband-reset after CRC Error\n");
-		if (amd_espi_inband_reset(amd_espi) != CB_SUCCESS) {
-                	pr_err("AMD_ESPI: In-band reset failed!\n");
-		}
+        if (ret == ESPI_NO_RESP_ERR || ret == ESPI_CRC_ERR) {
+                pr_info("AMD_ESPI: Triggering Inband-reset after CRC Error\n");
+                if (amd_espi_inband_reset(amd_espi) != CB_SUCCESS) {
+                        pr_err("AMD_ESPI: In-band reset failed!\n");
+                }
         }
 
+	/* clear downsteam command completion interrupt after command completion */
+	writel(ESPI_STATUS_DNCMD_COMPLETE, ESPI_BASE + ESPI_SLAVE0_INT_STS);
+
 	return ret;
 }
 
+static int amd_espi_inband_reset(struct amd_espi *amd_espi)
+{
+	u32 ret;
+	struct espi_txcmd cmd = {
+		.hdr0 = {
+			.cmd_type = IN_BAND_RESET,
+			.cmd_status = 1,
+		},
+	};
+
+	ret = espi_alloc_cmd_data(&cmd);
+	if(ret)
+		return ret;
+
+	ret = espi_send_cmd(amd_espi, &cmd);
+	if(ret != CB_SUCCESS) {
+		kfree(cmd.data);
+		return ret;
+	}
+	else
+		espi_set_initial_config(amd_espi);
+
+	kfree(cmd.data);
+	return CB_SUCCESS;
+}
+
 /*Set Slave config and cap reg vals*/
-static u32 amd_espi_setIoMode(struct amd_espi *amd_espi, u32 *slave_config,u32 *ctrlr_config, u32 io_mode)
+static u32 amd_espi_set_iomode(struct amd_espi *amd_espi, u32 *slave_config,u32 *ctrlr_config, u32 io_mode)
 {
 	struct espi_master *master = amd_espi->master;
 
@@ -282,7 +352,7 @@ static u32 amd_espi_setIoMode(struct amd_espi *amd_espi, u32 *slave_config,u32 *
 	return CB_SUCCESS;
 }
 
-static u32 amd_espi_setOpFreqMode(struct amd_espi* amd_espi, u32 *slave_config,u32 *ctrlr_config, u32 op_freq)
+static u32 amd_espi_set_freqmode(struct amd_espi* amd_espi, u32 *slave_config,u32 *ctrlr_config, u32 op_freq)
 {
 	struct espi_master *master = amd_espi->master;
 
@@ -323,9 +393,9 @@ static u32 amd_espi_setOpFreqMode(struct amd_espi* amd_espi, u32 *slave_config,u
 	return CB_SUCCESS;
 }
 
-static u32 amd_espi_GetConfig(struct amd_espi* amd_espi, u16 slave_reg_address, u32 *config)
+static u32 amd_espi_get_config(struct amd_espi* amd_espi, u16 slave_reg_address, u32 *config)
 {
-	u32 ret;
+	int ret;
 	struct espi_txcmd cmd = {
 		.hdr0 = {
 			.cmd_type = GET_CONFIGURATION,
@@ -335,13 +405,19 @@ static u32 amd_espi_GetConfig(struct amd_espi* amd_espi, u16 slave_reg_address,
 		},
 	};
 
+	ret = espi_alloc_cmd_data(&cmd);
+        if(ret)
+                return ret;
+
 	ret = espi_send_cmd(amd_espi, &cmd);
 	if (ret != CB_SUCCESS) {
+		kfree(cmd.data);
 		return ret;
 	}
 
 	*config = readl(ESPI_BASE + AMD_ESPI_DS_HEADER_REG1);
 
+	kfree(cmd.data);
 	return CB_SUCCESS;
 }
 
@@ -350,22 +426,22 @@ static int amd_espi_chenbl_info(struct amd_espi *amd_espi)
 	u32 chnl_config;
         u32 ret = 0;
 
-        if (amd_espi_GetConfig(amd_espi, ESPI_SLAVE_PERIPH_CFG, &chnl_config) == CB_SUCCESS) {
+        if (amd_espi_get_config(amd_espi, ESPI_SLAVE_PERIPH_CFG, &chnl_config) == CB_SUCCESS) {
                 if (chnl_config & ESPI_SLAVE_CHANNEL_ENABLE)
                         ret |= CHANNEL_MODE_PC;
         }
-        
-	if (amd_espi_GetConfig(amd_espi, ESPI_SLAVE_VW_CFG, &chnl_config) == CB_SUCCESS) {
+
+        if (amd_espi_get_config(amd_espi, ESPI_SLAVE_VW_CFG, &chnl_config) == CB_SUCCESS) {
                 if (chnl_config & ESPI_SLAVE_CHANNEL_ENABLE)
                         ret |= CHANNEL_MODE_VW;
-        } 
-        
-	if (amd_espi_GetConfig(amd_espi, ESPI_SLAVE_OOB_CFG, &chnl_config) == CB_SUCCESS) { 
+        }
+
+	if (amd_espi_get_config(amd_espi, ESPI_SLAVE_OOB_CFG, &chnl_config) == CB_SUCCESS) {
                 if (chnl_config & ESPI_SLAVE_CHANNEL_ENABLE)
                         ret |= CHANNEL_MODE_OOB;
         }
-        
-	if (amd_espi_GetConfig(amd_espi, ESPI_SLAVE_FLASH_CFG, &chnl_config) == CB_SUCCESS) {
+
+	if (amd_espi_get_config(amd_espi, ESPI_SLAVE_FLASH_CFG, &chnl_config) == CB_SUCCESS) {
                 if (chnl_config & ESPI_SLAVE_CHANNEL_ENABLE)
                         ret |= CHANNEL_MODE_FLASH;
         }
@@ -376,18 +452,20 @@ static int amd_espi_chenbl_info(struct amd_espi *amd_espi)
         return ret;
 }
 
-static int amd_espi_Get_General_Config(struct amd_espi* amd_espi, u32 *config)
+static int amd_espi_get_general_config(struct amd_espi* amd_espi, u32 *config)
 {
-	u32 ret = amd_espi_GetConfig(amd_espi, ESPI_SLAVE_GENERAL_CAPS_CFG, config);
+	u32 ret = amd_espi_get_config(amd_espi, ESPI_SLAVE_GENERAL_CAPS_CFG, config);
 	
-	if (ret != CB_SUCCESS)
+	if (ret != CB_SUCCESS) {
 		return ret;
+	}
 
 	return CB_SUCCESS;
 }
 
-static int amd_espi_SetConfig(struct amd_espi* amd_espi, u32 config, u16 slave_reg_address)
+static int amd_espi_set_config(struct amd_espi* amd_espi, u32 config, u16 slave_reg_address)
 {
+	int ret;
 	struct espi_txcmd cmd = {
 		.hdr0 = {
 			.cmd_type = SET_CONFIGURATION,
@@ -400,48 +478,56 @@ static int amd_espi_SetConfig(struct amd_espi* amd_espi, u32 config, u16 slave_r
 		},
 	};
 
-	return espi_send_cmd(amd_espi, &cmd);
+	ret = espi_alloc_cmd_data(&cmd);
+        if(ret)
+                return ret;
+
+	ret = espi_send_cmd(amd_espi, &cmd);
+	kfree(cmd.data);
+
+	return ret;
 }
 
-static int amd_espi_Set_General_Config(struct amd_espi *amd_espi, struct espi_device *dev)
+static int amd_espi_set_general_conf(struct amd_espi *amd_espi, struct espi_device *dev)
 {
 	int status = 0;
 	u32 slave_config = 0;
 	u32 ctrlr_config = readl(ESPI_BASE + CNTRL_SLAVE0_CONFIG_REG);
 
-	status = amd_espi_Get_General_Config(amd_espi, &slave_config);
+	status = amd_espi_get_general_config(amd_espi, &slave_config);
 	if (status != CB_SUCCESS) {
 		return status;
 	}
 
-	//Enable Alert mode by default
-	slave_config |= ESPI_SLAVE_ALERT_MODE_PIN;
-	ctrlr_config |= ESPI_ALERT_MODE;
+	if(amd_espi->master->caps.alert_mode == 1) {
+		slave_config |= ESPI_SLAVE_ALERT_MODE_PIN;
+		ctrlr_config |= ESPI_ALERT_MODE;
+	}
 
-	//Enable CRC check by default
-	slave_config |= ESPI_SLAVE_CRC_ENABLE;
-	ctrlr_config |= ESPI_CRC_CHECKING_EN;
+	if(amd_espi->master->caps.crc_check_support == 1) {
+		slave_config |= ESPI_SLAVE_CRC_ENABLE;
+		ctrlr_config |= ESPI_CRC_CHECKING_EN;
 
-	status = amd_espi_setIoMode(amd_espi, &slave_config, &ctrlr_config, dev->io_mode);
-	if (status != CB_SUCCESS)
+	}
+
+	status = amd_espi_set_iomode(amd_espi, &slave_config, &ctrlr_config, dev->io_mode);
+	if ( status != CB_SUCCESS )
 	{
 		pr_err("AMD_ESPI: %s, Error: IO mode not supported\n", __func__);
 		return -ENOTSUPP;
 	}
 
-	status = amd_espi_setOpFreqMode(amd_espi, &slave_config, &ctrlr_config, dev->op_freq);
+	status = amd_espi_set_freqmode(amd_espi, &slave_config, &ctrlr_config, dev->op_freq);
 	if (status != CB_SUCCESS)
 	{
 		pr_err("AMD_ESPI: %s, Error: op freq not supported\n", __func__);
 		return-ENOTSUPP;
 	}
 
-	status = amd_espi_SetConfig(amd_espi, slave_config, ESPI_SLAVE_GENERAL_CAPS_CFG);
+	status = amd_espi_set_config(amd_espi, slave_config, ESPI_SLAVE_GENERAL_CAPS_CFG);
 
 	if (status != CB_SUCCESS)
-	{
 		return status;
-	}
 
 	writel(ctrlr_config, (ESPI_BASE + CNTRL_SLAVE0_CONFIG_REG));
 	return CB_SUCCESS;
@@ -457,7 +543,7 @@ static u32 amd_espi_wait_channel_ready(struct amd_espi *amd_espi, u32 slave_reg_
 	timer.expires = jiffies + (HZ / 10);
 	add_timer(&timer);
 	do {
-		ret = amd_espi_GetConfig(amd_espi, slave_reg_addr, &config);
+		ret = amd_espi_get_config(amd_espi, slave_reg_addr, &config);
 		if (ret != CB_SUCCESS) {
 			return ret;
 		}
@@ -484,8 +570,7 @@ static u32 amd_espi_set_channel_configuration(struct amd_espi *amd_espi,u32 slav
 		u32 slave_reg_addr,
 		u32 ctrlr_enable)
 {
-	u32 ret = amd_espi_SetConfig(amd_espi, slave_config, slave_reg_addr);
-
+	u32 ret = amd_espi_set_config(amd_espi, slave_config, slave_reg_addr);
 	if (ret != CB_SUCCESS) { //set slave's peripheral channel
 		pr_err("AMD_ESPI:Channel: %s, set peripheral channel returing error\n", __func__);
 		return ret;
@@ -494,9 +579,10 @@ static u32 amd_espi_set_channel_configuration(struct amd_espi *amd_espi,u32 slav
 	if (!(slave_config & ESPI_SLAVE_CHANNEL_ENABLE)) //Channel ENABLE 
 		return CB_SUCCESS;
 
-	if (amd_espi_wait_channel_ready(amd_espi, slave_reg_addr) != CB_SUCCESS) {//Channel Ready
+	ret = amd_espi_wait_channel_ready(amd_espi, slave_reg_addr);
+	if (ret != CB_SUCCESS) {//Channel Ready
 		pr_err("AMD_ESPI:Channel: %s, channel_ready returing error\n", __func__);
-		return CB_ERR;
+		return ret;
 	}
 
 	amd_espi_enable_ctrlr_channel(amd_espi, ctrlr_enable); //On the master side set peripheral channel
@@ -506,14 +592,13 @@ static u32 amd_espi_set_channel_configuration(struct amd_espi *amd_espi,u32 slav
 static u32 amd_espi_setup_periph_channel(struct amd_espi *amd_espi, u32 slave_caps)
 {
 	struct espi_master *master = amd_espi->master;
-	u32 slave_config;
-	u32 ret;
-	
+	u32 slave_config, ret;
 	/* Peripheral channel requires BME bit to be set when enabling the channel. */
 	const u32 slave_en_mask =
 		ESPI_SLAVE_CHANNEL_ENABLE | ESPI_SLAVE_PERIPH_BUS_MASTER_ENABLE;
 
-	ret = amd_espi_GetConfig(amd_espi, ESPI_SLAVE_PERIPH_CFG, &slave_config);
+
+	ret = amd_espi_get_config(amd_espi, ESPI_SLAVE_PERIPH_CFG, &slave_config);
 	if (ret != CB_SUCCESS) {
 		return ret;
 	}
@@ -547,34 +632,60 @@ static u32 amd_espi_setup_periph_channel(struct amd_espi *amd_espi, u32 slave_ca
 static u32 amd_espi_setup_vw_channel(struct amd_espi *amd_espi, u32 slave_caps)
 {
         struct espi_master *master = amd_espi->master;
-        u32 slave_vw_caps;
-        u32 slave_config;
-	u32 ret;
+	u32 slave_vw_caps;
+	u32 slave_config, ret;
 
-        /* check if master supports VW */
-        if (!master->caps.vw_ch_en) {
-                dev_err(amd_espi->dev, "Master does not support VW\n");
-                return CB_ERR;
-        }
+	/* check if master supports VW */
+	if (!master->caps.vw_ch_en) {
+		dev_err(amd_espi->dev, "Master does not support VW\n");
+		return CB_ERR;
+	}
 
-        if (!(slave_caps & ESPI_SLAVE_VW_CH_SUPP)) {
-                dev_err(amd_espi->dev, "eSPI slave doesn't support VW channel!\n");
-                return CB_ERR;
-        }
+	if (!(slave_caps & ESPI_SLAVE_VW_CH_SUPP)) {
+		dev_err(amd_espi->dev, "eSPI slave doesn't support VW channel!\n");
+		return CB_ERR;
+	}
 
-	ret = amd_espi_GetConfig(amd_espi, ESPI_SLAVE_VW_CFG, &slave_vw_caps);
-        if (ret != CB_SUCCESS)
-                return ret;
+	ret = amd_espi_get_config(amd_espi, ESPI_SLAVE_VW_CFG, &slave_vw_caps);
+	if (ret != CB_SUCCESS) {
+		return ret;
+	}
 
         slave_config = slave_vw_caps | ESPI_SLAVE_CHANNEL_ENABLE;
 	/* Check if VW is already enabled. If yes, return success */
-        if (slave_config & ESPI_SLAVE_CHANNEL_ENABLE){
+        if (slave_config & ESPI_SLAVE_CHANNEL_ENABLE) {
                 return CB_SUCCESS;
         }
         return amd_espi_set_channel_configuration(amd_espi, slave_config, ESPI_SLAVE_VW_CFG,
                                                   CHANNEL_MODE_VW);
 }
 
+static u32 amd_espi_setup_oob_channel(struct amd_espi *amd_espi, u32 slave_caps)
+{
+        struct espi_master *master = amd_espi->master;
+        u32 slave_config, ret;
+
+        /* check if master supports OOB */
+        if (!master->caps.oob_ch_en) {
+                dev_err(amd_espi->dev, "Master does not support OOB\n");
+                return CB_ERR;
+        }
+
+        if (!(slave_caps & ESPI_SLAVE_OOB_CH_SUPP)) {
+                dev_err(amd_espi->dev, "eSPI slave doesn't support OOB channel!\n");
+                return CB_ERR;
+        }
+
+	ret = amd_espi_get_config(amd_espi, ESPI_SLAVE_OOB_CFG, &slave_config);
+        if (ret != CB_SUCCESS)
+                return ret;
+
+        slave_config |= ESPI_SLAVE_CHANNEL_ENABLE;
+
+        return amd_espi_set_channel_configuration(amd_espi, slave_config, ESPI_SLAVE_OOB_CFG,
+                                                  CHANNEL_MODE_OOB);
+}
+
 static void espi_get_io_mmio_decode_info(struct amd_espi *amd_espi, struct io_mmio_decode_config *config)
 {
 	config->io_mmio_dc_enable = readl(ESPI_BASE + ESPI_IO_MMIO_DECODE_EN_REG);
@@ -712,7 +823,7 @@ static int espi_periph_io_read(struct amd_espi* amd_espi, struct periph_io_rw *m
 			message_io->data.data_l = inl(message_io->port);
 			break;
 		default:
-			pr_info("AMD_ESPI: %s, Length of IO packet is not valid\n", __func__);
+			pr_err("AMD_ESPI: %s, Length of IO packet is not valid\n", __func__);
 			return CB_ERR;
 	}
 
@@ -894,14 +1005,12 @@ static int amd_espi_control_reg_init(struct amd_espi *amd_espi)
 {
 	u32 espi_version, global_ctrl_reg, global_ctrl_reg1;
 	u32 misc_cntrl = 0;
-	u32 polarity_reg = 0;
-	//u32 recv_vw_reg = 0;
+	u32 recv_vw_reg = 0;
+	u32 reg_val = 0;
 	
 	//(1) clear any existing active bits
-//	recv_vw_reg = readl(ESPI_BASE + ESPI_RECEIVE_VW_REG);
-//	pr_info("recv_vw_reg before : %x\n",recv_vw_reg);
-//	writel((recv_vw_reg | 0xFFFF6F00), (ESPI_BASE + ESPI_RECEIVE_VW_REG));
-//	pr_info("recv_vw_reg after : %x\n",recv_vw_reg);
+	recv_vw_reg = readl(ESPI_BASE + ESPI_RECEIVE_VW_REG);
+	writel((recv_vw_reg | 0xFFFF6F00), (ESPI_BASE + ESPI_RECEIVE_VW_REG));
 
 	/*(2) Check master_cap_reg version*/
 	espi_version = readl(ESPI_BASE + AMD_MASTER_CAP_REG); 
@@ -913,30 +1022,31 @@ static int amd_espi_control_reg_init(struct amd_espi *amd_espi)
 	if (!((global_ctrl_reg & 0x1) && (global_ctrl_reg & 0x2)))
 		global_ctrl_reg = global_ctrl_reg | 0x3;
 
-	//set watchdog value
 	/* (5)Set Wait State counter to 0x3F */
 	global_ctrl_reg = global_ctrl_reg | (0x3F << 23);
-
 	writel(global_ctrl_reg, (ESPI_BASE + AMD_ESPI_GLOBAL_CNTRL_REG0));
 
-	/* (7,10)Set Slave0 Error Interrupt enable[19:0] and Command interrupt enable [31:24] */
-	writel(ESPI_CRC_ERR, (ESPI_BASE + ESPI_SLAVE0_INT_EN));
+	/* (7) Set Slave0 Error Interrupt en [19:0] */
+	/* (10) Register command interrupt Enable [31:24] */
+	reg_val = readl(ESPI_BASE + ESPI_SLAVE0_INT_EN);
+	writel(reg_val | ESPI_ALL_ERR_INTR | ESPI_ALL_REG_CMD_INTR, (ESPI_BASE + ESPI_SLAVE0_INT_EN));
+
+	/* (8) Set eSPI Controller error Interrupt Mapping, default is SMI (1Fh) 
+	 * (11) Set Slave0 Error Interrupt enable[19:0] and Command interrupt enable [31:24] */
 	global_ctrl_reg1 = readl(ESPI_BASE + AMD_ESPI_GLOBAL_CNTRL_REG1);
-	global_ctrl_reg1 |= (ESPI_RGCMD_INT(23) | ESPI_ERR_INT_SMI);
+	global_ctrl_reg1 &= (~(0x1f << ESPI_ERR_INT_MAP_SHIFT));
+	global_ctrl_reg1 &= (~(0x1f << ESPI_RGCMD_INT_MAP_SHIFT));
+	global_ctrl_reg1 |= (ESPI_RGCMD_INT(amd_espi->irq) | ESPI_ERR_INT_SMI);
 	writel(global_ctrl_reg1, (ESPI_BASE + AMD_ESPI_GLOBAL_CNTRL_REG1));
 
 	/*(14) set the IRQ mask bit and polarity */
-	misc_cntrl = readl(ESPI_BASE + ESPI_VW_MISC_CNTRL_REG);
-	misc_cntrl |= ~(0xff);
-	writel(misc_cntrl,(ESPI_BASE + ESPI_VW_MISC_CNTRL_REG));
-
-	polarity_reg = readl(ESPI_BASE + ESPI_VW_POLARITY_REG);
-	writel((polarity_reg | 0xffffff), (ESPI_BASE + ESPI_VW_POLARITY_REG));
-
 	/*(15) enable to configure the VW index/data register*/
+	misc_cntrl = readl(ESPI_BASE + ESPI_VW_MISC_CNTRL_REG);
+	//Unmask IRQ 0~23
+	misc_cntrl = misc_cntrl & ~(GENMASK(31, 8));
 	writel((misc_cntrl | 0xf), (ESPI_BASE + ESPI_VW_MISC_CNTRL_REG));
 
-	/* (16,17)espi Bus Master Enable and program the eSPI req not with vw req */ 
+	/* (16,17) espi Bus Master Enable and program the eSPI req not with vw req */ 
 	if( !(global_ctrl_reg1 & ESPI_BUS_MASTER_EN)){        
 		global_ctrl_reg1 = global_ctrl_reg1 | ESPI_BUS_MASTER_EN | BIT(21);
 		writel( global_ctrl_reg1, (ESPI_BASE + AMD_ESPI_GLOBAL_CNTRL_REG1));
@@ -948,14 +1058,23 @@ static int amd_espi_control_reg_init(struct amd_espi *amd_espi)
 static void espi_set_initial_config(struct amd_espi *amd_espi)
 {
 	uint32_t espi_initial_mode = 0;
+	u32 reg_val;
+
 	espi_initial_mode = readl(ESPI_BASE + CNTRL_SLAVE0_CONFIG_REG);
 	espi_initial_mode |= ((CNTRL_SLAVE0_OP_FREQ_16 << 25) | (IO_MODE_SINGLE << 28));
 
-	//Enable CRC and Alert mode by default
-	espi_initial_mode |= ESPI_ALERT_MODE; 
-	espi_initial_mode |= ESPI_CRC_CHECKING_EN;
+	if(amd_espi->master->caps.alert_mode == 1)
+		espi_initial_mode |= ESPI_ALERT_MODE; 
+
+	if(amd_espi->master->caps.crc_check_support == 1)
+		espi_initial_mode |= ESPI_CRC_CHECKING_EN;
 
 	writel(espi_initial_mode, (ESPI_BASE + CNTRL_SLAVE0_CONFIG_REG));
+	
+	reg_val = readl(ESPI_BASE + ESPI_VW_MISC_CNTRL_REG);
+	//Unmask IRQ 0~23
+	reg_val = reg_val & ~(GENMASK(31, 8));
+	writel((reg_val | 0xf) , (ESPI_BASE + ESPI_VW_MISC_CNTRL_REG));
 }
 
 static int amd_espi_init_slave(struct amd_espi *amd_espi, struct espi_device *espi_dev)
@@ -965,29 +1084,30 @@ static int amd_espi_init_slave(struct amd_espi *amd_espi, struct espi_device *es
 	u32 slave_caps = 0;
 	u32 global_ctrl_reg = 0;
 
-	espi_set_initial_config(amd_espi);
-	if (amd_espi_inband_reset(amd_espi) != CB_SUCCESS) {
-		pr_err("AMD_ESPI: In-band reset failed!\n");
-		return CB_ERR;
-	}
-
 	ret = amd_espi_get_master_cap(amd_espi, master);
 	if (ret != CB_SUCCESS) {
 		pr_err("AMD_ESPI: %s, master capability returns error\n", __func__);
 		return -ENOTSUPP;
 	}
 
+	espi_set_initial_config(amd_espi);
+	ret = amd_espi_inband_reset(amd_espi);
+	if (ret != CB_SUCCESS) {
+		pr_err("AMD_ESPI: In-band reset failed!\n");
+		return ret;
+	}
+
 	ret = set_def_initial_config(master, espi_dev);
 	if (ret != CB_SUCCESS) {
 		pr_err("AMD_ESPI: %s, def_initial_config returns error\n", __func__);
 		return -ENOTSUPP;
 	}
 
-	ret = amd_espi_Set_General_Config(amd_espi, espi_dev);
+	ret = amd_espi_set_general_conf(amd_espi, espi_dev);
 	if (ret != CB_SUCCESS)
 		return ret;
 
-	ret = amd_espi_Get_General_Config(amd_espi, &slave_caps);
+	ret = amd_espi_get_general_config(amd_espi, &slave_caps);
 	if (ret != CB_SUCCESS)
 		return ret;
 
@@ -1000,6 +1120,11 @@ static int amd_espi_init_slave(struct amd_espi *amd_espi, struct espi_device *es
 		return CB_ERR;
 	}
 
+	if (amd_espi_setup_vw_channel(amd_espi, slave_caps) != CB_SUCCESS){
+ 
+		pr_err("AMD_ESPI: %s: amd_espi_setup_vw_channel failed\n", __func__);
+		return CB_ERR;
+	} 
 	return CB_SUCCESS;
 }
 
@@ -1254,355 +1379,766 @@ static int espi_periph_mem_read(struct amd_espi* amd_espi, struct periph_mem_rw*
 	return CB_SUCCESS;
 }
 
-static long amd_espi_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+static int set_espi_intr_config(struct amd_espi* amd_espi, unsigned int config)
 {
-	struct amd_espi *amd_espi;
-	struct espi_device *dev;
-	struct config *config = NULL;
-	struct periph_io_rw *message_io = NULL;
-	struct espi_master *master = NULL;
-	struct io_mmio_decode_config *io_dc_config = NULL;
-	struct periph_mem_rw *mem_data = NULL;
-	u32 ret;
-	u32 ret_val;
-	u32 slave_config;
-	u32 ctrlr_config;
-	u32 io_range = 0;
-	int op_freq = 0;
-	int io_mode = 0; 
-	
-	amd_espi = filp->private_data;
-	master = amd_espi->master;
-
-	dev = kzalloc(sizeof(struct espi_device), GFP_KERNEL);
-	if (!dev)
-		return -ENOMEM;
-
-	config = kzalloc(sizeof(struct config), GFP_KERNEL);
-	if (!config)
-		return -ENOMEM;
-
-	message_io = kzalloc(sizeof(struct periph_io_rw), GFP_KERNEL);
-        if (!message_io)
-                return -ENOMEM;
+	writel(config, (ESPI_BASE + ESPI_SLAVE0_INT_EN));
+	return (readl(ESPI_BASE + ESPI_SLAVE0_INT_EN) == config);
+}
 
-	io_dc_config = kzalloc(sizeof(struct io_mmio_decode_config), GFP_KERNEL);
-        if (!io_dc_config)
-                return -ENOMEM;
-	
-	mem_data = kzalloc(sizeof(struct periph_mem_rw), GFP_KERNEL);
-        if (!mem_data)
-                return -ENOMEM;
+static int amd_espi_put_vwire(struct amd_espi* amd_espi, struct vw_packet *packet)
+{
+	struct espi_txcmd cmd;
+	int ret, data_len;
 
-	/* Check type and command number */
-	if (_IOC_TYPE(cmd) != ESPI_MAGIC_NUMBER)
-		return -EINVAL;
+	cmd.hdr0.cmd_type = VW_CHNL;
+	cmd.hdr0.cmd_status = 1;
+	cmd.hdr0.hdata0 = packet->index_count;
+	cmd.hdr0.hdata1 = 0;
+	cmd.hdr0.hdata2 = 0;
 
-	switch(cmd)
-	{
-		case ESPI_SET_CONFIG :
-			if (copy_from_user(config, (struct config*)arg, sizeof(struct config))) {
-				return -EFAULT;
-			}
+	cmd.hdr1.val = 0;
+	cmd.hdr2.val = 0;
 
-			if (config->io_mode == IO_MODE_SINGLE)
-				dev->io_mode = IO_MODE_SINGLE;
-			else if (config->io_mode == IO_MODE_DUAL)
-				dev->io_mode = IO_MODE_DUAL;
-			else if (config->io_mode == IO_MODE_QUAD)
-				dev->io_mode = IO_MODE_QUAD;
+	ret = espi_alloc_cmd_data(&cmd);
+        if(ret)
+                return ret;
 
-			if (config->op_freq == SLAVE_OP_FREQ_16)
-				dev->op_freq = SLAVE_OP_FREQ_16;
-			else if(config->op_freq == SLAVE_OP_FREQ_33)
-				dev->op_freq = SLAVE_OP_FREQ_33;
-			else if(config->op_freq == SLAVE_OP_FREQ_66)
-				dev->op_freq = SLAVE_OP_FREQ_66;
+	data_len = (cmd.hdr0.hdata0 + 1) * sizeof(struct vw_data);
+	data_len = DATA_SIZE_ROUNDOFF_4(data_len);
 
-			ret_val = amd_espi_Set_General_Config(amd_espi, dev);
-			if (ret_val != CB_SUCCESS)
-				return ret_val;
-
-			/* Channel Config */
-			ret_val = amd_espi_Get_General_Config(amd_espi, &slave_config);
-			if (ret_val != CB_SUCCESS)
-				return ret_val;
-
-			if (config->channel_mode == CHANNEL_MODE_PC){
-                                ret = amd_espi_setup_periph_channel(amd_espi, slave_config);
-                                if (ret) {
-                                        dev_err(amd_espi->dev, "amd_espi_setup_periph_channel failed\n");
-                                        return CB_ERR;
-                                }
-                        } else if(config->channel_mode == CHANNEL_MODE_VW) {
-                                ret = amd_espi_Get_General_Config(amd_espi, &slave_config);
-                                if (ret) {
-                                        dev_err(amd_espi->dev, "amd_espi_Get_General_Config for channel failed\n");
-                                        return CB_ERR;
-                                }
-
-                                ret = amd_espi_setup_vw_channel(amd_espi, slave_config);
-                                if (ret) {
-                                        dev_err(amd_espi->dev,
-                                        "amd_espi_setup_VW_channel failed\n");
-                                        return CB_ERR;
-                                }
-                        } else {
-                                dev_err(amd_espi->dev, "Opted channel not suported\n");
-                                return CB_ERR;
-                        }
-			break;
+	memcpy(cmd.data, packet->data, data_len);
+	
+	ret = espi_send_cmd(amd_espi, &cmd);
+	
+	kfree(cmd.data);
+	return ret;
+}
 
-		case ESPI_GET_CONFIG:
+static void amd_espi_get_vwire(struct amd_espi *amd_espi)
+{
+	uint32_t status = readl(ESPI_BASE + ESPI_SLAVE0_INT_STS);
+	uint32_t index = readl(ESPI_BASE + ESPI_RX_VW_IDX_REG);
+	uint32_t rxvw_data = readl(ESPI_BASE + ESPI_RX_VW_DATA_REG);
 
-			ret_val = amd_espi_Get_General_Config(amd_espi, &ret);
-			if(ret_val != CB_SUCCESS)
-				return ret_val;
-
-			io_mode = (ret & (0x3 << ESPI_SLAVE_IO_MODE_SEL_SHIFT)) >> 26;
-			switch (io_mode) {
-				case IO_MODE_SINGLE:
-					config->io_mode = IO_MODE_SINGLE;
-					break;
-				case IO_MODE_DUAL:
-					config->io_mode = IO_MODE_DUAL;
-					break;
-				case IO_MODE_QUAD:
-					config->io_mode = IO_MODE_QUAD;
-					break;
-				default:
-					pr_err("AMD_ESPI: io_mode default case, returning error\n");
-					return CB_ERR;
-			}
+	pr_info("AMD_ESPI: eSPI Virtual wire Event received\n");
+	
+	/* PPR GET_VW step 2 - read IRQ status for index 0 event */
+	if ((status & ESPI_RXVW_GRP0_INT) && !(index & VW_GRP0_MASK)) 
+	{
+		uint32_t regval = readl(ESPI_BASE + ESPI_RECEIVE_VW_REG);
+		int irq_data = VW_IDX0_DATA(rxvw_data & GENMASK(7, 0)); 
+		
+		pr_info("AMD_ESPI: VW index 0 event\n");
+		regval = (regval & ~IRQ_SEL_MASK) | irq_data;
 
-			op_freq = (ret & (0x7 << ESPI_SLAVE_OP_FREQ_SEL_SHIFT)) >> 20;
-			switch (op_freq) {
-				case SLAVE_OP_FREQ_16:
-					config->op_freq = SLAVE_OP_FREQ_16;
-					break;
-				case SLAVE_OP_FREQ_33:
-					config->op_freq = SLAVE_OP_FREQ_33;
-					break;
-				case SLAVE_OP_FREQ_66:
-					config->op_freq = SLAVE_OP_FREQ_66;
-					break;
-				default: 
-					pr_err("AMD_ESPI: op_freq default case, returning error\n");
-					return CB_ERR;
-			}
+		//Write IRQ to read the status of interested IRQ.
+		writel(regval, ESPI_BASE + ESPI_RECEIVE_VW_REG);
+		
+		//Read the register to get the irq status of IRQ written above. 
+		regval = readl(ESPI_BASE + ESPI_RECEIVE_VW_REG);
+		pr_info("AMD_ESPI: Virtual Wire IRQ selection: 0x%lx\tIRQ status: 0x%lx\n",
+			regval & IRQ_SEL_MASK, (regval & IRQ_STA_MASK) >> 5);
+	}
 
+	/* PPR GET_VW step 4 - reading the data from group VW*/
+	if (status & ESPI_ALL_VW_INTR)
+	{
 
-			/* Channel enable info*/           
-			ret = amd_espi_chenbl_info(amd_espi);
-			config->channel_mode = 0;
-
-			if (ret == CB_ERR)
-                                config->channel_mode = CHAN_NOT_ENABLED;
-                        else {
-                                if(ret & CHANNEL_MODE_PC){
-                                        config->channel_mode |= CHANNEL_MODE_PC;
-                                }
-                                if(ret & CHANNEL_MODE_VW){
-                                        config->channel_mode |= CHANNEL_MODE_VW;
-                                }
-                                if(ret & CHANNEL_MODE_OOB){
-                                        config->channel_mode |= CHANNEL_MODE_OOB;
-                                }
-                                if(ret & CHANNEL_MODE_FLASH){
-                                        config->channel_mode |= CHANNEL_MODE_FLASH;
-                                }
-                        }
-
-			if (copy_to_user((struct config*)arg, config, sizeof(struct config)))
+		if(status & ESPI_RXVW_GRP0_INT) {
+			uint32_t index = index & VW_GRP0_MASK;
+			uint32_t grp0_data = rxvw_data & VW_GRP0_MASK;
+			if (index <= 1) /* Interrupt Event */
 			{
-				return -EFAULT;
-			}
-			break;
+				pr_info("AMD_ESPI: ESPI VW Interrupt Event\n");
+				pr_info("AMD_ESPI: VW Index: 0x%x\tVW data: 0x%x\n"
+					"AMD_ESPI: Interrupt line: 0x%lx\tInterrupt Level: %s\n",
+					index, grp0_data,
+					index ? VW_IDX1_DATA(grp0_data) : VW_IDX0_DATA(grp0_data),
+					VW_INTR_IRQ_LVL(grp0_data) ? "1-High" : "0-Low");
 
-		case ESPI_INBAND_RESET:
-			if (amd_espi_inband_reset(amd_espi) != CB_SUCCESS) {
-				pr_err("AMD_ESPI: In-band reset failed!\n");
-				return CB_ERR;
 			}
-			break;
-		case ESPI_SET_IO_MODE:
+			else
+				pr_info("AMD_ESPI: ESPI VW Group 0 event: index: 0x%x\tdata: 0x%xn",
+					index, grp0_data);
+
+		} else if(status & ESPI_RXVW_GRP1_INT) {
+			uint32_t grp1_data = (rxvw_data & VW_GRP1_MASK) >> 8 ;
+			pr_info("AMD_ESPI: ESPI VW Group 1 Event: index: 0x%lx\tdata: 0x%x\n",
+				 (index & VW_GRP1_MASK) >> 8, grp1_data);
+
+		} else if(status & ESPI_RXVW_GRP2_INT) {
+			uint32_t grp2_data = (rxvw_data & VW_GRP2_MASK) >> 16;
+			pr_info("AMD_ESPI: ESPI VW Group 2 Event: index: 0x%lx\tdata: 0x%x\n",
+				 (index & VW_GRP2_MASK) >> 16, grp2_data);
+
+		} else 	if(status & ESPI_RXVW_GRP3_INT) {
+			uint32_t grp3_data = (rxvw_data & VW_GRP3_MASK) >> 24;
+			if((((index & VW_GRP3_MASK) >> 24) >= 128) &&
+			    (((index & VW_GRP3_MASK) >> 24) <= 255))
+				pr_info("AMD_ESPI: GPIO Expander Event\n");
+
+			pr_info("AMD_ESPI: ESPI VW Group 3 Event: index: 0x%lx\tdata: 0x%x\n",
+				 (index & VW_GRP3_MASK) >> 24, grp3_data);
+		}
+	} else { /* PPR step 3 to read the system events */
+		uint32_t sys_event = readl(ESPI_BASE + ESPI_RECEIVE_VW_REG);
+		
+		if(sys_event & CPUTEMP_REQ)
+			pr_info("AMD_ESPI: CPUTEMP_REQ\n");
+		if(sys_event & HOST_RST_ACK)
+			pr_info("AMD_ESPI: HOST_RST_ACK");
+		if(sys_event & RCIN_B)
+			pr_info("AMD_ESPI: RCIN_B");
+		if(sys_event & SMI_B)
+			pr_info("AMD_ESPI: SMI_B");
+		if(sys_event & SCI_B)
+			pr_info("AMD_ESPI: SCI_B");
+		if(sys_event & SLAVE_BOOT_LOAD_STS)
+			pr_info("AMD_ESPI: SLAVE_BOOT_LOAD_STS");
+		if(sys_event & ERROR_NONFATAL)
+			pr_info("AMD_ESPI: ERROR_NONFATAL");
+		if(sys_event & ERROR_FATAL)
+			pr_info("AMD_ESPI: ERROR_FATAL");
+		if(sys_event & SLAVE_BOOT_LOAD_DONE)
+			pr_info("AMD_ESPI: SLAVE_BOOT_LOAD_DONE");
+		if(sys_event & PME_B)
+			pr_info("AMD_ESPI: PME_B");
+		if(sys_event & WAKE_B)
+			pr_info("AMD_ESPI: WAKE_B");
+		if(sys_event & OOB_RST_ACK)
+			pr_info("AMD_ESPI: OOB_RST_ACK");
+		else
+			pr_info("AMD_ESPI: Unknown event");
+	}
+}
 
-			if (copy_from_user(config, (struct config*)arg, sizeof(struct config))) {
-				return -EFAULT;
-			}
-			ctrlr_config = readl(ESPI_BASE + CNTRL_SLAVE0_CONFIG_REG);
+static int amd_espi_configure_vw_index(struct amd_espi *amd_espi, 
+		struct conf_vw_index *vw_config)
+{
+	u32 vw_index_sel = readl(ESPI_BASE + ESPI_RX_VW_IDX_REG);
+	
+	vw_index_sel = vw_index_sel & ~(GENMASK(7, 0) << (vw_config->group * BIT(3)));	
+	vw_index_sel = vw_index_sel | (vw_config->index << (vw_config->group * BIT(3)));
+	writel(vw_index_sel, ESPI_BASE + ESPI_RX_VW_IDX_REG);
+	
+	return CB_SUCCESS;
+}
 
-			ret_val = amd_espi_Get_General_Config(amd_espi, &slave_config);
-			if (ret_val != CB_SUCCESS) {
-				return ret_val;
-			}
+static int amd_espi_ioctl_set_config(struct amd_espi *amd_espi, unsigned long arg)
+{
+        u32 slave_config, ret, io_mode, op_freq;
+	struct espi_device *dev = NULL;
+        struct config *config = NULL;
 
-			ret = amd_espi_setIoMode(amd_espi, &slave_config, &ctrlr_config, config->io_mode);
-			if (ret != CB_SUCCESS)
-			{
-				pr_err("AMD_ESPI: Set IO mode failed\n");
-				return CB_ERR;
-			}
+	dev = kzalloc(sizeof(struct espi_device), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+	config = kzalloc(sizeof(struct config), GFP_KERNEL);
+	if (!config){
+		kfree(dev);
+		return -ENOMEM;
+	}
 
-			ret = amd_espi_SetConfig(amd_espi, slave_config, ESPI_SLAVE_GENERAL_CAPS_CFG);
-			if (ret != CB_SUCCESS) {
-				pr_err("AMD_ESPI: Set IO mode failed\n");
-				return ret;
-			}
-			writel(ctrlr_config, (ESPI_BASE + CNTRL_SLAVE0_CONFIG_REG));
-			break;
+	if (copy_from_user(config, (struct config*)arg, sizeof(struct config))) {
+		ret = -EFAULT;
+		goto set_config_free;
+	}
 
-		case ESPI_SET_CHAN_MODE :
-			if (copy_from_user(config, (struct config*)arg, sizeof(struct config))) {
-				return -EFAULT;
-			}
+	io_mode = config->io_mode;
+	if (io_mode != IO_MODE_SINGLE && io_mode != IO_MODE_DUAL && io_mode != IO_MODE_QUAD) {
+                pr_err("AMD_ESPI: Invalid io mode\n");
+                ret = -ENOTSUPP;
+                goto set_config_free;
+        } else {
+                dev->io_mode = config->io_mode;
+        }
 
-			switch(config->channel_mode){
-				case CHANNEL_MODE_PC :
-					ret_val = amd_espi_Get_General_Config(amd_espi, &slave_config);
-					if (ret_val != CB_SUCCESS){
-						pr_err("AMD_ESPI: amd_espi_Get_General_Config for channel failed\n");
-						return ret_val;
-					}
-
-					if ((amd_espi_setup_periph_channel(amd_espi, slave_config)) != CB_SUCCESS) {
-						pr_err("AMD_ESPI: amd_espi_setup_periph_channel failed\n");
-						return CB_ERR;
-					}
-
-					break;
-				case CHANNEL_MODE_VW:
-					ret_val = amd_espi_Get_General_Config(amd_espi, &slave_config);
-					if (ret_val != CB_SUCCESS){
-                                                pr_err("AMD_ESPI: amd_espi_Get_General_Config for channel failed\n");
-                                                return ret_val;
-                                        }
-
-                                        if (amd_espi_setup_vw_channel(amd_espi, slave_config) != CB_SUCCESS){
-                                                pr_err("AMD_ESPI: %s: amd_espi_setup_VW_channel failed\n", __func__);
-                                                return CB_ERR;
-                                        }
-					break;
-				case CHANNEL_MODE_OOB:
-					pr_err("AMD_ESPI: OOB channel not supported\n");
-					break;
-				case CHANNEL_MODE_FLASH:
-					pr_err("AMD_ESPI: FLASH Channel not supported\n");
-					break;
-				default:
-					pr_err("AMD_ESPI:Channel: not supported\n");
-					return CB_ERR;
-			}
+	op_freq = config->op_freq;
+	if (op_freq != SLAVE_OP_FREQ_16 && op_freq != SLAVE_OP_FREQ_33 && op_freq != SLAVE_OP_FREQ_66) {
+                pr_err("AMD_ESPI: Invalid operating frequency\n");
+                ret = -ENOTSUPP;
+                goto set_config_free;
+        } else {
+                dev->op_freq = config->op_freq;
+        }
+
+	ret = amd_espi_set_general_conf(amd_espi, dev);
+	if (ret != CB_SUCCESS)
+		goto set_config_free;
+
+	/* Channel Config */
+	ret = amd_espi_get_general_config(amd_espi, &slave_config);
+	if (ret != CB_SUCCESS)
+		goto set_config_free;
+
+	if (config->channel_mode == CHANNEL_MODE_PC){
+		ret = amd_espi_setup_periph_channel(amd_espi, slave_config);
+		if (ret) {
+			dev_err(amd_espi->dev, "amd_espi_setup_periph_channel failed\n");
+			ret = CB_ERR;
+			goto set_config_free;
+		}
+	} else if(config->channel_mode == CHANNEL_MODE_VW) {
+		ret = amd_espi_setup_vw_channel(amd_espi, slave_config);
+		if (ret) {
+			dev_err(amd_espi->dev,
+					"amd_espi_setup_VW_channel failed\n");
+			ret = CB_ERR;
+			goto set_config_free;
+		}
+	} else if(config->channel_mode == CHANNEL_MODE_OOB) {
+		ret = amd_espi_setup_oob_channel(amd_espi, slave_config);
+		if (ret) {
+			dev_err(amd_espi->dev, "amd_espi_setup_VW_channel failed\n");
+			ret = CB_ERR;
+			goto set_config_free;
+		}
+	} else {
+		dev_err(amd_espi->dev, "Opted channel not suported\n");
+		ret = CB_ERR;
+		goto set_config_free;
+	}
+
+	set_config_free:
+		kfree(dev);
+		kfree(config);
+	return ret;
+}
+
+static int amd_espi_ioctl_get_config(struct amd_espi *amd_espi, unsigned long arg)
+{
+	struct config *config = NULL;
+	u32 op_freq, io_mode, ret, slave_conf;
+
+	config = kzalloc(sizeof(struct config), GFP_KERNEL);
+	if (!config) {
+		return -ENOMEM;
+	}
+
+	ret = amd_espi_get_general_config(amd_espi, &slave_conf);
+	if(ret != CB_SUCCESS)
+		goto get_config_free;
 
+	io_mode = (slave_conf & (0x3 << ESPI_SLAVE_IO_MODE_SEL_SHIFT)) >> 26;
+	switch (io_mode) {
+		case IO_MODE_SINGLE:
+			config->io_mode = IO_MODE_SINGLE;
 			break;
-		case  ESPI_SET_FREQ :
+		case IO_MODE_DUAL:
+			config->io_mode = IO_MODE_DUAL;
+			break;
+		case IO_MODE_QUAD:
+			config->io_mode = IO_MODE_QUAD;
+			break;
+		default:
+			pr_err("AMD_ESPI: io_mode default case, returning error\n");
+			ret = CB_ERR;
+			goto get_config_free;
+	}
+	op_freq = (slave_conf & (0x7 << ESPI_SLAVE_OP_FREQ_SEL_SHIFT)) >> 20;
+	switch (op_freq) {
+		case SLAVE_OP_FREQ_16:
+			config->op_freq = SLAVE_OP_FREQ_16;
+			break;
+		case SLAVE_OP_FREQ_33:
+			config->op_freq = SLAVE_OP_FREQ_33;
+			break;
+		case SLAVE_OP_FREQ_66:
+			config->op_freq = SLAVE_OP_FREQ_66;
+			break;
+		default:
+			pr_err("AMD_ESPI: op_freq default case, returning error\n");
+			ret = CB_ERR;
+			goto get_config_free;
+	}
+	/* Channel enable info*/
+	ret = amd_espi_chenbl_info(amd_espi);
+	config->channel_mode = 0;
 
-			if (copy_from_user(config, (struct config*)arg, sizeof(struct config))) {
-				return -EFAULT;
-			}
-			ctrlr_config = readl(ESPI_BASE + CNTRL_SLAVE0_CONFIG_REG);
+	if (ret == CB_ERR) {
+		config->channel_mode = CHAN_NOT_ENABLED;
+	} else {
+		if(ret & CHANNEL_MODE_PC)
+			config->channel_mode |= CHANNEL_MODE_PC;
+		if(ret & CHANNEL_MODE_VW)
+			config->channel_mode |= CHANNEL_MODE_VW;
+		if(ret & CHANNEL_MODE_OOB)
+			config->channel_mode |= CHANNEL_MODE_OOB;
+		if(ret & CHANNEL_MODE_FLASH)
+			config->channel_mode |= CHANNEL_MODE_FLASH;
+	}
 
-			ret_val = amd_espi_Get_General_Config(amd_espi, &slave_config);
-			if (ret_val != CB_SUCCESS) {
-				return ret_val;
-			}
+	if (copy_to_user((struct config*)arg, config, sizeof(struct config))){
+		ret = -EFAULT;
+		goto get_config_free;
+	}
+	ret = 0;
+	get_config_free:
+		kfree(config);
+	return ret;
 
+}
 
-			ret = amd_espi_setOpFreqMode(amd_espi, &slave_config,&ctrlr_config, config->op_freq);
-			if (ret != CB_SUCCESS)
-			{
-				pr_err("AMD_ESPI: Set OP Freq failed\n");
-				return CB_ERR;
-			}
+static int amd_espi_ioctl_set_io_mode(struct amd_espi *amd_espi, unsigned long arg)
+{
+	u32 ctrlr_config, slave_config, ret;
+	struct config *config = NULL;
+
+	config = kzalloc(sizeof(struct config), GFP_KERNEL);
+	if (!config)
+		return -ENOMEM;
 
-			ret = amd_espi_SetConfig(amd_espi, slave_config,ESPI_SLAVE_GENERAL_CAPS_CFG);
+	if (copy_from_user(config, (struct config*)arg, sizeof(struct config))){
+		ret = -EFAULT;
+		goto set_io_mode_free;
+	}
+
+	ctrlr_config = readl(ESPI_BASE + CNTRL_SLAVE0_CONFIG_REG);
+
+	ret = amd_espi_get_general_config(amd_espi, &slave_config);
+	if (ret != CB_SUCCESS)
+		goto set_io_mode_free;
+
+	ret = amd_espi_set_iomode(amd_espi, &slave_config, &ctrlr_config, config->io_mode);
+	if (ret != CB_SUCCESS)
+	{
+		pr_err("AMD_ESPI: Set IO mode failed\n");
+		goto set_io_mode_free;
+	}
+
+	ret = amd_espi_set_config(amd_espi, slave_config, ESPI_SLAVE_GENERAL_CAPS_CFG);
+	if (ret != CB_SUCCESS) {
+		pr_err("AMD_ESPI: Set IO mode failed\n");
+		goto set_io_mode_free;
+	}
+	writel(ctrlr_config, (ESPI_BASE + CNTRL_SLAVE0_CONFIG_REG));
+
+	set_io_mode_free:
+		kfree(config);
+	return ret;
+}
+
+static int amd_espi_ioctl_set_channel_mode(struct amd_espi *amd_espi, unsigned long arg)
+{
+	struct config *config = NULL;
+	u32 slave_config, ret;
+
+	config = kzalloc(sizeof(struct config), GFP_KERNEL);
+	if (!config)
+		return -ENOMEM;
+
+	if (copy_from_user(config, (struct config*)arg, sizeof(struct config))) {
+		ret = -EFAULT;
+		goto set_chan_mode_free;
+	}
+
+	ret = amd_espi_get_general_config(amd_espi, &slave_config);
+	if (ret != CB_SUCCESS){
+		pr_err("AMD_ESPI: amd_espi_get_general_config for channel failed\n");
+		goto set_chan_mode_free;
+	}
+	switch(config->channel_mode){
+		case CHANNEL_MODE_PC :
+			ret = amd_espi_setup_periph_channel(amd_espi, slave_config);
 			if (ret != CB_SUCCESS) {
-				pr_err("AMD_ESPI: Set OP Freq failed\n");
-				return ret;
+				pr_err("AMD_ESPI: amd_espi_setup_periph_channel failed\n");
+				goto set_chan_mode_free;
 			}
-			writel(ctrlr_config, (ESPI_BASE + CNTRL_SLAVE0_CONFIG_REG));
 
 			break;
-		case ESPI_IO_WRITE:
-			if (copy_from_user(message_io, (struct periph_io_rw *)arg, sizeof(struct periph_io_rw))) {
-				return -EFAULT;
+		case CHANNEL_MODE_VW:
+			ret = amd_espi_setup_vw_channel(amd_espi, slave_config);
+			if (ret != CB_SUCCESS){
+				pr_err("AMD_ESPI: %s: amd_espi_setup_VW_channel failed\n", __func__);
+				goto set_chan_mode_free;
 			}
+			break;
+		case CHANNEL_MODE_OOB:
+			if ((ret = amd_espi_setup_oob_channel(amd_espi, slave_config)) != CB_SUCCESS){
+				pr_err("AMD_ESPI: %s: amd_espi_setup_VW_channel failed\n", __func__);
+				goto set_chan_mode_free;
+			}
+			break;
+		case CHANNEL_MODE_FLASH:
+			pr_err("AMD_ESPI: FLASH not supported\n");
+			goto set_chan_mode_free;
+			break;
+		default:
+			pr_err("AMD_ESPI:Channel: not supported\n");
+			ret = CB_ERR;
+	}
+
+	set_chan_mode_free:
+		kfree(config);
+	return ret;
+}
+
+static int amd_espi_ioctl_set_frequency(struct amd_espi *amd_espi, unsigned long arg)
+{
+	u32 ctrlr_config, slave_config, ret;
+	struct config *config = NULL;
+
+	config = kzalloc(sizeof(struct config), GFP_KERNEL);
+	if (!config)
+		return -ENOMEM;
+
+	if (copy_from_user(config, (struct config*)arg, sizeof(struct config))){
+		ret = -EFAULT;
+		goto set_freq_free;
+	}
+
+	ctrlr_config = readl(ESPI_BASE + CNTRL_SLAVE0_CONFIG_REG);
+
+	ret = amd_espi_get_general_config(amd_espi, &slave_config);
+	if (ret != CB_SUCCESS)
+		goto set_freq_free;
+
+	ret = amd_espi_set_freqmode(amd_espi, &slave_config,&ctrlr_config, config->op_freq);
+	if (ret != CB_SUCCESS)
+	{
+		pr_err("AMD_ESPI: Set OP Freq failed\n");
+		goto set_freq_free;
+	}
+
+	ret = amd_espi_set_config(amd_espi, slave_config,ESPI_SLAVE_GENERAL_CAPS_CFG);
+	if (ret != CB_SUCCESS) {
+		pr_err("AMD_ESPI: Set OP Freq failed\n");
+		goto set_freq_free;
+	}
+	writel(ctrlr_config, (ESPI_BASE + CNTRL_SLAVE0_CONFIG_REG));
+
+	set_freq_free:
+		kfree(config);
+	return ret;
+}
+
+static int amd_espi_ioctl_io_write(struct amd_espi *amd_espi, unsigned long arg)
+{
+	struct periph_io_rw *message_io = NULL;
+	u32 ret;
+
+	message_io = kzalloc(sizeof(struct periph_io_rw), GFP_KERNEL);
+	if (!message_io)
+		return -ENOMEM;
+
+	if (copy_from_user(message_io, (struct periph_io_rw *)arg, sizeof(struct periph_io_rw))){
+		ret = -EFAULT;
+		goto io_write_free;
+	}
+
+	ret = espi_periph_io_write(amd_espi, message_io);
+
+	io_write_free:
+		kfree(message_io);
+	return ret;
+}
+
+static int amd_espi_ioctl_io_read(struct amd_espi *amd_espi, unsigned long arg)
+{
+	struct periph_io_rw *message_io = NULL;
+	u32 ret;
+
+	message_io = kzalloc(sizeof(struct periph_io_rw), GFP_KERNEL);
+	if (!message_io)
+		return -ENOMEM;
+
+	if (copy_from_user(message_io, (struct periph_io_rw *)arg, sizeof(struct periph_io_rw))) {
+		ret = -EFAULT;
+		goto io_read_free;
+	}
+
+	ret = espi_periph_io_read(amd_espi, message_io);
+	if (ret != CB_SUCCESS)
+		goto io_read_free;
 
-			ret = espi_periph_io_write(amd_espi, message_io);
+	if (copy_to_user((struct periph_io_rw*)arg, message_io, sizeof(struct periph_io_rw))) {
+		ret = -EFAULT;
+		goto io_read_free;
+	}
+
+	io_read_free:
+		kfree(message_io);
+	return ret;
+
+}
+
+static int amd_espi_ioctl_get_io_decode_config(struct amd_espi *amd_espi, unsigned long arg)
+{
+	struct io_mmio_decode_config *io_dc_config = NULL;
+	u32 ret = 0;
+
+	io_dc_config = kzalloc(sizeof(struct io_mmio_decode_config), GFP_KERNEL);
+	if (!io_dc_config)
+		return -ENOMEM;
+
+	espi_get_io_mmio_decode_info(amd_espi, io_dc_config);
+
+	if (copy_to_user((struct io_mmio_decode_config *)arg, io_dc_config, sizeof(struct io_mmio_decode_config)))
+		ret = -EFAULT;
+
+	kfree(io_dc_config);
+	return ret;
+
+}
+
+static int amd_espi_ioctl_enable_io_decode_config(struct amd_espi *amd_espi, unsigned long arg)
+{
+	struct io_mmio_decode_config *io_dc_config = NULL;
+	u32 ret = 0;
+
+	io_dc_config = kzalloc(sizeof(struct io_mmio_decode_config), GFP_KERNEL);
+	if (!io_dc_config)
+		return -ENOMEM;
+
+	if (copy_from_user(io_dc_config, (struct io_mmio_decode_config *)arg, sizeof(struct io_mmio_decode_config))) {
+		ret = -EFAULT;
+		goto decode_config_free;
+	}
+	espi_set_io_mmio_decode_config(amd_espi, io_dc_config);
+
+	decode_config_free:
+		kfree(io_dc_config);
+	return ret;
+}
+
+static int amd_espi_ioctl_memory_write(struct amd_espi *amd_espi, unsigned long arg)
+{
+	struct periph_mem_rw *mem_data = NULL;
+	u32 ret;
+
+	mem_data = kzalloc(sizeof(struct periph_mem_rw), GFP_KERNEL);
+	if (!mem_data)
+		return -ENOMEM;
+
+	if (copy_from_user(mem_data, (struct periph_mem_rw *)arg, sizeof(struct periph_mem_rw))) {
+		ret = -EFAULT;
+		goto mem_write_free;
+	}
+
+	ret = espi_periph_mem_write(amd_espi, mem_data);
+
+	mem_write_free:
+		kfree(mem_data);
+	return ret;
+}
+
+static int amd_espi_ioctl_memory_read(struct amd_espi *amd_espi, unsigned long arg)
+{
+	struct periph_mem_rw *mem_data = NULL;
+	u32 ret;
+
+	mem_data = kzalloc(sizeof(struct periph_mem_rw), GFP_KERNEL);
+	if (!mem_data)
+		return -ENOMEM;
+
+	if (copy_from_user(mem_data, (struct periph_mem_rw *)arg, sizeof(struct periph_mem_rw))){
+		ret = -EFAULT;
+		goto mem_read_free;
+	}
+	ret = espi_periph_mem_read(amd_espi, mem_data);
+	if (ret != CB_SUCCESS) {
+		ret = CB_ERR;
+		goto mem_read_free;
+	}
+	if (copy_to_user((struct periph_mem_rw*)arg, mem_data, sizeof(struct periph_mem_rw)))
+		ret = -EFAULT;
+
+	mem_read_free:
+		kfree(mem_data);
+	return ret;
+}
+
+static int amd_espi_ioctl_put_vw(struct amd_espi *amd_espi, unsigned long arg)
+{
+	struct vw_packet vw_pac;
+	void *dat;
+	u32 ret;
+
+	/* copy index count */
+	if (copy_from_user(&vw_pac, (struct vw_packet *)arg,  sizeof(vw_pac)))
+		return -EFAULT;
+
+	/* copy user space base address of vw_data*/
+	dat = vw_pac.data;
+
+	vw_pac.data = kzalloc(sizeof(struct vw_data) * (vw_pac.index_count+1), GFP_KERNEL);
+	if (!vw_pac.data) {
+		pr_err("Memory allocation failure\n");
+		return -ENOMEM;
+	}
+
+	/* copy index count entries of vw_data from user space to kernel space buffer*/
+	if (copy_from_user(vw_pac.data, dat,
+				sizeof(struct vw_data) * (vw_pac.index_count+1))){
+		ret = -EFAULT;
+		goto put_vw_free;
+	}
+
+	ret = amd_espi_put_vwire(amd_espi, &vw_pac);
+
+	put_vw_free:
+		kfree(vw_pac.data);
+
+	return ret;
+}
+
+static int amd_espi_ioctl_configure_vw_index(struct amd_espi *amd_espi, unsigned long arg)
+{
+	struct conf_vw_index *conf_vw = NULL;
+	u32 ret;
+
+	conf_vw = kzalloc(sizeof(struct conf_vw_index), GFP_KERNEL);
+	if (!conf_vw)
+		return -ENOMEM;
+
+	if (copy_from_user(conf_vw, (struct conf_vw_index*)arg, sizeof(struct conf_vw_index))){
+		ret = -EFAULT;
+		goto config_idx_free;
+	}
+
+	ret = amd_espi_configure_vw_index(amd_espi, conf_vw);
+
+	config_idx_free:
+		kfree(conf_vw);
+
+	return ret;
+
+}
+
+static void clr_espi_all_interrupts(struct amd_espi* amd_espi)
+{
+        /* set all 1's to clear all the interrupt */
+        writel(GENMASK(31, 0), (ESPI_BASE + ESPI_SLAVE0_INT_STS));
+}
+
+static void amd_espi_ioctl_enable_bmc_uart_vw(struct amd_espi *amd_espi)
+{
+	struct io_mmio_decode_config config;
+
+	config.io_mmio_dc_enable = IO_DECODE_RANGE0;
+	config.range0.base_addr_range0 = 0x3f8;
+	config.range0.val = 0x3f8;
+	config.range2.val =  0x10;
+
+	espi_set_io_mmio_decode_config(amd_espi, &config);
+
+	/* Configure VW index for VW events from BMC  */
+        int regval = readl(ESPI_BASE + ESPI_RX_VW_IDX_REG);
+        regval = 0x80ffff00 | (regval & ~GENMASK(31, 24));
+        writel(regval, ESPI_BASE + ESPI_RX_VW_IDX_REG);
+
+	bmc_uart_enable_ioctl();
+	pr_info("AMD_ESPI: BMC UART setting done for VW event\n");
+	clr_espi_all_interrupts(amd_espi);
+}
+
+static long amd_espi_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	struct amd_espi *amd_espi;
+	u32 io_range = 0;
+	u32 ret = 0;
+
+	amd_espi = filp->private_data;
+
+	/* Check type and command number */
+	if (_IOC_TYPE(cmd) != ESPI_MAGIC_NUMBER)
+		return -EINVAL;
+
+	switch(cmd)
+	{
+		case ESPI_SET_CONFIG :
+			ret = amd_espi_ioctl_set_config(amd_espi, arg);
+			break;
+
+		case ESPI_GET_CONFIG:
+			ret = amd_espi_ioctl_get_config(amd_espi, arg);
+			break;
+
+		case ESPI_INBAND_RESET:
+			ret = amd_espi_inband_reset(amd_espi);
 			if (ret != CB_SUCCESS) {
-				return CB_ERR;
+				pr_err("AMD_ESPI: In-band reset failed!\n");
 			}
 			break;
+		case ESPI_SET_IO_MODE:
+			ret = amd_espi_ioctl_set_io_mode(amd_espi, arg);
+			break;
+
+		case ESPI_SET_CHAN_MODE :
+			ret = amd_espi_ioctl_set_channel_mode(amd_espi, arg);
+			break;
+
+		case  ESPI_SET_FREQ :
+			ret = amd_espi_ioctl_set_frequency(amd_espi, arg);
+			break;
+
+		case ESPI_IO_WRITE:
+			ret = amd_espi_ioctl_io_write(amd_espi, arg);
+			break;
 
 		case ESPI_IO_READ:
-			if (copy_from_user(message_io, (struct periph_io_rw *)arg, sizeof(struct periph_io_rw))) {
-				return -EFAULT;
-			}
-			ret = espi_periph_io_read(amd_espi, message_io);
-			if (ret != CB_SUCCESS) {
-				return CB_ERR;
-			}
-			if (copy_to_user((struct periph_io_rw*)arg, message_io, sizeof(struct periph_io_rw))) {
-				return -EFAULT;
-			}
+			ret = amd_espi_ioctl_io_read(amd_espi, arg);
 			break;
 
 		case ESPI_GET_IODECODE_CONFIG:
-                        espi_get_io_mmio_decode_info(amd_espi, io_dc_config);
-
-                        if (copy_to_user((struct io_mmio_decode_config *)arg, io_dc_config, sizeof(struct io_mmio_decode_config)))
-                        {
-                            return -EFAULT;
-                        }
-                        break;
-			
+			ret = amd_espi_ioctl_get_io_decode_config(amd_espi, arg);
+			break;
+
 		case ESPI_EN_IODECODE_CONFIG:
-                        if (copy_from_user(io_dc_config, (struct io_mmio_decode_config *)arg, sizeof(struct io_mmio_decode_config))) {
-                            return -EFAULT;
-                        }
-        
-                        espi_set_io_mmio_decode_config(amd_espi, io_dc_config);
+			ret = amd_espi_ioctl_enable_io_decode_config(amd_espi, arg);
 			break;
 
 		case ESPI_DS_IODECODE_CONFIG:
 			if (copy_from_user(&io_range, (unsigned int *)arg, sizeof(unsigned int))) {
-				return -EFAULT;
+				ret = -EFAULT;
+				break;
 			}
-
 			espi_disable_io_decode_range(amd_espi, io_range);
 			break;
+
 		case ESPI_MEM_WRITE:
-                        if (copy_from_user(mem_data, (struct periph_mem_rw *)arg, sizeof(struct periph_mem_rw))) {
-                               return -EFAULT;
-                       }
+			ret = amd_espi_ioctl_memory_write(amd_espi, arg);
+			break;
+
+		case ESPI_MEM_READ:
+			ret = amd_espi_ioctl_memory_read(amd_espi, arg);
+			break;
+
+		case ESPI_PUT_VW:
+			ret = amd_espi_ioctl_put_vw(amd_espi, arg);
+			break;
+		
+		case ESPI_INTERRUPT_CONFIG:
+			u32 intr_config;
+			if (copy_from_user(&intr_config, (u32 *)arg, sizeof(intr_config))){
+				ret = -EFAULT;
+				break;
+			}
+
+			ret = set_espi_intr_config(amd_espi, intr_config);
+			if (!ret) 
+				ret = CB_ERR;
+			break;
+
+		/* The below ioctls commands are only for debugging purposes to  verify the VW use cases */	
+		case ESPI_CONFIGURE_VW_INDEX:
+			ret = amd_espi_ioctl_configure_vw_index(amd_espi, arg);
+			break;
+
+		case ESPI_CLEAR_INTERRUPT:
+			clr_espi_all_interrupts(amd_espi);
+			break;
+
+		case BMC_ENABLE_UART:
+			amd_espi_ioctl_enable_bmc_uart_vw(amd_espi);
+			break;
 
-                       ret = espi_periph_mem_write(amd_espi, mem_data);
-                       if (ret != CB_SUCCESS) {
-                               return CB_ERR;
-                       }
-                       break;
-                case ESPI_MEM_READ:
-                       if (copy_from_user(mem_data, (struct periph_mem_rw *)arg, sizeof(struct periph_mem_rw))) {
-                               return -EFAULT;
-                       }
-                       ret = espi_periph_mem_read(amd_espi, mem_data);
-                       if (ret != CB_SUCCESS) {
-                               return CB_ERR;
-                       }
-                       if (copy_to_user((struct periph_mem_rw*)arg, mem_data, sizeof(struct periph_mem_rw))) {
-                               return -EFAULT;
-                       }
-                       break;
 		default:
 			pr_err("AMD_ESPI: ESPI command not found, returning error\n");
-			return -EINVAL;
+			ret = -EINVAL;
 	}
-	kfree(dev);
-	kfree(config);
-	kfree(message_io);
-	kfree(io_dc_config);
-	kfree(mem_data);
-	return CB_SUCCESS;
+
+	return ret;
 }
 
 static int amd_espi_open(struct inode *inode, struct file *filp)
@@ -1658,6 +2194,33 @@ static int amd_espi_release(struct inode *inode, struct file *filp)
 	return status;
 }
 
+static irqreturn_t espi_alert_irq_handler(int irq, void *dev_id)
+{
+	struct amd_espi* amd_espi = dev_id;
+        u32 val = readl(ESPI_BASE + ESPI_SLAVE0_INT_STS);
+        irqreturn_t ret = IRQ_NONE;
+
+	/* Ignore the interrupt if it is for downstream command completion.
+	 * Sender of the downstream command will clear the interrupt status
+	 * after confirming that commnd is sent successfully. Also ignore the 
+	 * interrupt with command status 0 as it received when clearing the interrupts.
+	 */ 
+	if (!(val) || (val & ESPI_STATUS_DNCMD_COMPLETE)) {
+		return IRQ_NONE;
+	} 
+	
+	/* Handle the interrupt if it is belongs to any of the virtual wire group interrupts */
+	if (val & ESPI_ALL_VW_INTR) {
+		amd_espi_get_vwire(amd_espi);
+	
+		/* clear all the interrupts after handling*/
+		clr_espi_all_interrupts(amd_espi);
+		ret = IRQ_HANDLED;
+	}
+
+	return ret;
+}
+
 static struct file_operations amd_espi_fops = {
 	.owner = THIS_MODULE,
 	.unlocked_ioctl = amd_espi_ioctl,
@@ -1671,6 +2234,7 @@ static int amd_espi_probe(struct platform_device *pdev)
 	struct amd_espi* amd_espi;
 	struct device* dev = &pdev->dev;
 	struct espi_device *espi_dev;
+	void __iomem *pm_espi_irqctrl;
 	int err;
 	int ret = -1;
 
@@ -1679,70 +2243,129 @@ static int amd_espi_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	amd_espi->master = devm_kzalloc(dev, sizeof(struct espi_master), GFP_KERNEL);
-	if (!amd_espi->master)
+	if (!amd_espi->master){
+		kfree(amd_espi);
 		return -ENOMEM;
+	}
 
 	INIT_LIST_HEAD(&amd_espi->device_entry);
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res)
-		return -ENOMEM;
+	if (!res) {
+		ret = -ENOTSUPP;
+		goto espi_alloc_free;
+	}
 
 	amd_espi->io_remap_addr = devm_ioremap_resource(dev, res);
-
 	if (IS_ERR(amd_espi->io_remap_addr)) {
 		err = PTR_ERR(amd_espi->io_remap_addr);
 		dev_err(dev, "error %d ioremap of eSPI registers failed\n", err);
-		return err;
+		ret = err;
+		goto espi_alloc_free;
 	}
 
 	ret = alloc_chrdev_region(&amd_espi->dev_minor, 0, ESPI_DEV_MINORS, "amd_espi");
 	if (ret < 0)
 	{
 		pr_err("AMD_ESPI: Device numbers allocation failed: %d\n", ret);
-		return ret;
+		goto espi_alloc_free;
 	}
-	cdev_init(&cdev, &amd_espi_fops);
-	cdev_add(&cdev, amd_espi->dev_minor, N_ESPI_MINORS);
 
 	amd_espi_dev_class = class_create("amd_espi");
 	if (IS_ERR(amd_espi_dev_class))
 	{
 		pr_err("AMD_ESPI: class_create faied\n");
-		cdev_del(&cdev);
-		return PTR_ERR(amd_espi_dev_class);
+		ret = PTR_ERR(amd_espi_dev_class);
+		goto espi_unregister_chrdev;
 	}
+	
+	cdev_init(&cdev, &amd_espi_fops);
+	ret = cdev_add(&cdev, amd_espi->dev_minor, N_ESPI_MINORS);
+
+	if (ret)
+		goto espi_class_cleanup;
 
 	amd_espi->dev = dev;
 	dev = device_create(amd_espi_dev_class, NULL, amd_espi->dev_minor, &amd_espi, "amd_espi");
 	if (IS_ERR(dev))
 	{
 		pr_err("AMD_ESPI: device_create faied\n");
-		class_destroy(amd_espi_dev_class);
-		cdev_del(&cdev);
-		return PTR_ERR(dev);
-	}
-	else {
-		list_add(&amd_espi->device_entry, &device_list);
+		ret = PTR_ERR(dev);
+		goto espi_del_dev;
 	}
-
+	
+	list_add(&amd_espi->device_entry, &device_list);
 	platform_set_drvdata(pdev, amd_espi);
 
 	//allocate mem for espi_device
 	espi_dev = devm_kzalloc(dev, sizeof(struct espi_device), GFP_KERNEL);
-	if (!espi_dev)
-		return -ENOMEM;
+	if (!espi_dev){
+		ret = -ENOMEM;
+		goto espidev_list_free;
+	}
 
-	err = amd_espi_control_reg_init(amd_espi);
-	if (err != CB_SUCCESS)
-		return -ENOTSUPP;
+	amd_espi->irq = platform_get_irq(pdev, 0);
+	if (amd_espi->irq < 0) {
+                ret = amd_espi->irq;
+		goto espidev_alloc_free;
+	}
 
-	err = amd_espi_init_slave(amd_espi, espi_dev);
-	if (err != CB_SUCCESS)
-		return -ENOTSUPP;
+	err = amd_espi_control_reg_init(amd_espi);	
+	if (err != CB_SUCCESS) {
+		ret = -ENOTSUPP;
+		goto espidev_alloc_free;
+	}
 
+	err = amd_espi_init_slave(amd_espi, espi_dev);
+	if (err != CB_SUCCESS) {
+		ret = -ENOTSUPP;
+		goto espidev_alloc_free;
+	}
+	
+	/* Register eSPI interrupt handler */
+	ret = devm_request_irq(dev, amd_espi->irq, espi_alert_irq_handler, IRQF_ONESHOT|IRQF_SHARED,
+			dev_name(dev), amd_espi);
+	
+	if (ret) {
+		pr_err("AMD_ESPI: Irq register failed for %d\n", amd_espi->irq);
+		goto espidev_alloc_free;
+	} 
+	
 	pr_info("AMD ESPI device initialization completed\n");
 
+	/* Unmask the eSPI irq 0 to 23 in PM espi interrupt control register */
+	pm_espi_irqctrl = ioremap(ESPI_FCH_PM_ADDR, 4);
+	iowrite32(0x0, pm_espi_irqctrl);
+	iounmap(pm_espi_irqctrl);
+
+	/* Configure VW index for VW events from BMC, for index 0 and index 128 */
+        writel(0x80ffff00, ESPI_BASE + ESPI_RX_VW_IDX_REG);
+
+	clr_espi_all_interrupts(amd_espi);
+	kfree(espi_dev);	
+	
 	return 0;
+
+espidev_alloc_free:
+	kfree(espi_dev);
+
+espidev_list_free:
+	list_del(&amd_espi->device_entry);
+	device_destroy(amd_espi_dev_class, amd_espi->dev_minor);
+
+espi_del_dev:
+	cdev_del(&cdev);
+
+espi_class_cleanup:
+	class_destroy(amd_espi_dev_class);
+
+espi_unregister_chrdev:
+	unregister_chrdev_region(amd_espi->dev_minor, ESPI_DEV_MINORS);
+
+espi_alloc_free:
+	kfree(amd_espi->master);
+	kfree(amd_espi);
+
+	return ret;
 }
 
 static int amd_espi_remove(struct platform_device *pdev)
@@ -1751,8 +2374,8 @@ static int amd_espi_remove(struct platform_device *pdev)
 
 	list_del(&amd_espi->device_entry);
 	device_destroy(amd_espi_dev_class, amd_espi->dev_minor);
-	class_destroy(amd_espi_dev_class);
 	cdev_del(&cdev);
+	class_destroy(amd_espi_dev_class);
 	unregister_chrdev_region(amd_espi->dev_minor, ESPI_DEV_MINORS);
 	kfree(amd_espi->master);
 	kfree(amd_espi);
@@ -1789,4 +2412,3 @@ MODULE_PARM_DESC(espi_op_freq, "An integer, 16/33/66");
 
 MODULE_LICENSE("Dual BSD/GPL");
 MODULE_AUTHOR("AMD Linux Platform driver team");
-MODULE_DESCRIPTION("ESPI Controller device driver");
diff --git a/drivers/spi/espi-err.h b/drivers/spi/espi-err.h
index 398079258..0986b5c55 100644
--- a/drivers/spi/espi-err.h
+++ b/drivers/spi/espi-err.h
@@ -1,3 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
+ *
+ * AMD eSPI controller driver
+ *
+ * Copyright (c) 2020, Advanced Micro Devices, Inc.
+ */
+
 /* ERROR CODE - BIT POSITION */
 #define POS_BUS_TIMING          0
 #define POS_BUS_WAIT_STATE      1
@@ -35,21 +42,21 @@
 
 /* Human-readable error strings */
 static char *espi_error_codes[] = {
-        "ERR 00: eSPI BUS TIMING ERROR",
-        "ERR 01: eSPI WAIT STATE TIMER TIMEOUT",
-        "ERR 02: eSPI CRC ERROR",
-        "",
-        "ERR 04: NO RESPONSE FROM SLAVE",
-        "ERR 05: FATAL_ERROR RESPONSE FROM SLAVE",
-        "ERR 06: NON_FATAL_ERROR RESPONSE FROM SLAVE",
-        "ERR 07: INVALID RESPONSE CODE RECEIVED",
-        "ERR 08: INVALID CYCLE TYPE RECEIVED",
-        "ERR 09: UNSUCCESSFUL COMPLETION PACKET",
-        "ERR 10: ILLEGAL RESPONSE TAG",
-        "ERR 11: ILLEGAL RESPONSE LENGTH",
-        "ERR 12: OOB PACKET DATA LENGTH ERROR",
-        "ERR 13: PC MESSAGE DATA LENGTH ERROR",
-        "ERR 14: FLASH PACKET DATA LENGTH ERROR",
-        "ERR 15: PROTOCOL ERROR",
+	"ERR 00: eSPI BUS TIMING ERROR",
+	"ERR 01: eSPI WAIT STATE TIMER TIMEOUT",
+	"ERR 02: eSPI CRC ERROR",
+	"",
+	"ERR 04: NO RESPONSE FROM SLAVE",
+	"ERR 05: FATAL_ERROR RESPONSE FROM SLAVE",
+	"ERR 06: NON_FATAL_ERROR RESPONSE FROM SLAVE",
+	"ERR 07: INVALID RESPONSE CODE RECEIVED",
+	"ERR 08: INVALID CYCLE TYPE RECEIVED",
+	"ERR 09: UNSUCCESSFUL COMPLETION PACKET",
+	"ERR 10: ILLEGAL RESPONSE TAG",
+	"ERR 11: ILLEGAL RESPONSE LENGTH",
+	"ERR 12: OOB PACKET DATA LENGTH ERROR",
+	"ERR 13: PC MESSAGE DATA LENGTH ERROR",
+	"ERR 14: FLASH PACKET DATA LENGTH ERROR",
+	"ERR 15: PROTOCOL ERROR",
 };
 
diff --git a/drivers/spi/espi.h b/drivers/spi/espi.h
index 649b7f5f8..6f69901ef 100644
--- a/drivers/spi/espi.h
+++ b/drivers/spi/espi.h
@@ -1,9 +1,22 @@
+/* SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
+ *
+ * AMD eSPI controller driver
+ *
+ * Copyright (c) 2020, Advanced Micro Devices, Inc.
+ */
+
 #include <linux/ioctl.h>
 #include <linux/uaccess.h>
 
 #define CB_SUCCESS 0
 #define CB_ERR     -1
 
+#define DATA_SIZE_ROUNDOFF_4(size) ((size+3) & (~0x03u))
+
+/* Timeouts */
+#define ESPI_MSG_DELAY_MIN_US 50
+#define ESPI_RESP_MAX_TIMEOUT 200000	// 200 ms
+
 /*Master dependent register*/
 #define AMD_ESPI_DS_HEADER_REG0      0x00
 #define AMD_ESPI_DS_HEADER_REG1      0x04
@@ -11,10 +24,10 @@
 #define AMD_ESPI_DS_DATA_REG0        0x0C
 
 /*Slave dependent register*/
-#define ESPI_IO_MMIO_DECODE_EN_REG    0x40       //40+70*N+00
-#define ESPI_TARGET_RANGE_REG0     0x44	//40+70*N+04	
-#define ESPI_TARGET_RANGE_REG1     0x48	//40+70*N+08	
-#define ESPI_TARGET_RANGE_REG2     0x4C	//40+70*N+0C
+#define ESPI_IO_MMIO_DECODE_EN_REG	0x40	//40+70*N+00
+#define ESPI_TARGET_RANGE_REG0		0x44	//40+70*N+04
+#define ESPI_TARGET_RANGE_REG1		0x48	//40+70*N+08
+#define ESPI_TARGET_RANGE_REG2		0x4C	//40+70*N+0C
 
 #define ESPI_TARGET_MMIO_REG0                0x50       //40+70*N+10
 #define ESPI_TARGET_MMIO_REG1                0x54       //40+70*N+14
@@ -29,35 +42,48 @@
 #define AMD_INT_ENABLE               0x6C       //40+70*N+2C
 #define AMD_INT_STATUS               0x70       //40+70*N+30
 
-#define ESPI_RECEIVE_VW_REG           0x9C      //40+70*N+5C
-#define ESPI_RECEIVE_VW_DATA_REG      0xA0     //40+70*N+60
-#define ESPI_RECEIVE_VW_INDEX_REG     0xA4     //40+70*N+64
+#define ESPI_RECEIVE_VW_REG      0x9C      //40+70*N+5C
+#define ESPI_RX_VW_DATA_REG      0xA0     //40+70*N+60
+#define ESPI_RX_VW_IDX_REG	0xA4     //40+70*N+64
 #define ESPI_VW_MISC_CNTRL_REG        0xA8     //40+70*N+68
 #define ESPI_VW_POLARITY_REG          0xAC     //40+70*N+6C
 
 /*Slave Status*/
 #define ESPI_SLAVE0_INT_EN           0x6c
 #define ESPI_SLAVE0_INT_STS          0x70
-#define ESPI_STATUS_DNCMD_COMPLETE   (1 << 28)
-#define ESPI_STATUS_NON_FATAL_ERROR  (1 << 6)
-#define ESPI_STATUS_FATAL_ERROR      (1 << 5)
-#define ESPI_STATUS_NO_RESPONSE	     (1 << 4)
-#define ESPI_STATUS_CRC_ERR          (1 << 2)
-#define ESPI_STATUS_WAIT_TIMEOUT     (1 << 1)
-#define ESPI_STATUS_BUS_ERROR	     (1 << 0)
-#define ESPI_PC_MSG_RCVD	     (1 << 29)
+
+#define ESPI_STATUS_NON_FATAL_ERROR  BIT(6)
+#define ESPI_STATUS_FATAL_ERROR      BIT(5)
+#define ESPI_STATUS_NO_RESPONSE	     BIT(4)
+#define ESPI_STATUS_CRC_ERR          BIT(2)
+#define ESPI_STATUS_WAIT_TIMEOUT     BIT(1)
+#define ESPI_STATUS_BUS_ERROR	     BIT(0)
+
+#define ESPI_ALL_ERR_INTR	     GENMASK(19, 0)
+#define ESPI_ALL_REG_CMD_INTR	     GENMASK(31, 24)
+
+#define ESPI_PC_MSG_RCVD	     BIT(29)
+#define ESPI_STATUS_DNCMD_COMPLETE   BIT(28)
+#define ESPI_RXVW_GRP0_INT           BIT(24)
+#define ESPI_RXVW_GRP1_INT           BIT(25)
+#define ESPI_RXVW_GRP2_INT           BIT(26)
+#define ESPI_RXVW_GRP3_INT           BIT(27)
+#define ESPI_ALL_VW_INTR	(ESPI_RXVW_GRP0_INT|ESPI_RXVW_GRP1_INT|\
+		ESPI_RXVW_GRP2_INT|ESPI_RXVW_GRP3_INT)
 
 /*Master capability and control Reg*/
 #define AMD_MASTER_CAP_REG           0x2C
 #define AMD_ESPI_GLOBAL_CNTRL_REG0   0x30
 #define AMD_ESPI_GLOBAL_CNTRL_REG1   0x34
+#define AMD_ESPI_MISC_CONTROL_REG0   0x38
+#define AMD_ESPI_MISC_CONTROL_REG1   0x3c
 #define ESPI_BUS_MASTER_EN			(1 << 1)
 #define ESPI_ERR_INT_MAP_SHIFT		 8
 #define ESPI_ERR_INT(irq)			 ((irq) << ESPI_ERR_INT_MAP_SHIFT)
-#define ESPI_ERR_INT_SMI			 (0x1f << ESPI_ERR_INT_MAP_SHIFT)   
+#define ESPI_ERR_INT_SMI			(0x1f << ESPI_ERR_INT_MAP_SHIFT)
 #define ESPI_RGCMD_INT_MAP_SHIFT	 13
 #define ESPI_RGCMD_INT(irq)			 ((irq) << ESPI_RGCMD_INT_MAP_SHIFT)
-#define ESPI_RGCMD_INT_SMI			 (0x1f << ESPI_RGCMD_INT_MAP_SHIFT) 
+#define ESPI_RGCMD_INT_SMI			(0x1f << ESPI_RGCMD_INT_MAP_SHIFT)
 
 /*Master/Slave capability config*/
 #define CHANNEL_MODE_PC              BIT(3)
@@ -76,12 +102,12 @@
 #define IO_MODE_DUAL                 0x1
 #define IO_MODE_QUAD                 0x2
 
-/* 
+/*
  * Operating Support Frequency values
  * 000 - 16.7 MHz
  * 001 - 16.7 MHz, 33 MHz
  * 011 - 16.7 MHz, 33 MHz, 66 MHz
-*/
+ */
 #define CNTRL_OP_FREQ_16                   0x0
 #define CNTRL_OP_FREQ_33                   0x1
 #define CNTRL_OP_FREQ_66                   0x3
@@ -109,15 +135,74 @@
 #define ESPI_DS_IODECODE_CONFIG      _IOWR(ESPI_MAGIC_NUMBER, 0xb, unsigned int)
 #define ESPI_MEM_WRITE               _IOWR(ESPI_MAGIC_NUMBER, 0xc, struct periph_mem_rw)
 #define ESPI_MEM_READ                _IOWR(ESPI_MAGIC_NUMBER, 0xd, struct periph_mem_rw)
-
-#define IO_DECODE_RANGE0  0x0100
-#define IO_DECODE_RANGE1  0x0200
-#define IO_DECODE_RANGE2  0x0400
-#define IO_DECODE_RANGE3  0x0800
-#define MMIO_DECODE_RANGE0           0x1000
-#define MMIO_DECODE_RANGE1           0x2000
-#define MMIO_DECODE_RANGE2           0x4000
-#define MMIO_DECODE_RANGE3           0x8000
+#define ESPI_INTERRUPT_CONFIG	     _IOW(ESPI_MAGIC_NUMBER, 0xe, u32)
+#define ESPI_PUT_VW                  _IOW(ESPI_MAGIC_NUMBER, 0xf, struct vw_packet)
+#define ESPI_CONFIGURE_VW_INDEX      _IOW(ESPI_MAGIC_NUMBER, 0x10, struct conf_vw_index)
+#define ESPI_CLEAR_INTERRUPT         _IO(ESPI_MAGIC_NUMBER, 0x20)
+#define BMC_ENABLE_UART              _IO(ESPI_MAGIC_NUMBER, 0x30)
+
+#define IO_DECODE_RANGE0	0x0100
+#define IO_DECODE_RANGE1	0x0200
+#define IO_DECODE_RANGE2	0x0400
+#define IO_DECODE_RANGE3	0x0800
+#define MMIO_DECODE_RANGE0	0x1000
+#define MMIO_DECODE_RANGE1	0x2000
+#define MMIO_DECODE_RANGE2	0x4000
+#define MMIO_DECODE_RANGE3	0x8000
+
+/* VW group Masks */
+#define VW_GRP0_MASK	GENMASK(7, 0)
+#define VW_GRP1_MASK	GENMASK(15, 8)
+#define VW_GRP2_MASK	GENMASK(23, 16)
+#define VW_GRP3_MASK	GENMASK(31, 24)
+#define IRQ_SEL_MASK	GENMASK(4, 0)
+#define IRQ_STA_MASK	GENMASK(7, 5)
+
+#define VW_INTR_IRQ_LVL(data)	((data) & BIT(7))
+#define VW_IDX0_DATA(data)	((data) & GENMASK(6, 0))
+#define VW_IDX1_DATA(data)	(((data) & GENMASK(6, 0)) + 128)
+
+/*VW error codes*/
+#define CPUTEMP_REQ                  BIT(31)
+#define HOST_RST_ACK                 BIT(19)
+#define RCIN_B                       BIT(18)
+#define SMI_B                        BIT(17)
+#define SCI_B                        BIT(16)
+#define SLAVE_BOOT_LOAD_STS          BIT(15)
+#define ERROR_NONFATAL               BIT(14)
+#define ERROR_FATAL                  BIT(13)
+#define SLAVE_BOOT_LOAD_DONE         BIT(12)
+#define PME_B                        BIT(11)
+#define WAKE_B                       BIT(10)
+#define OOB_RST_ACK                  BIT(8)
+
+/* IRQ select lines*/
+#define IRQ0                         0x00
+#define IRQ1                         0x01
+#define IRQ2                         0x02
+#define IRQ3                         0x03
+#define IRQ4                         0x04
+#define IRQ5                         0x05
+#define IRQ6                         0x06
+#define IRQ7                         0x07
+#define IRQ8                         0x08
+#define IRQ9                         0x09
+#define IRQ10                        0x0A
+#define IRQ11                        0x0B
+#define IRQ12                        0x0C
+#define IRQ13                        0x0D
+#define IRQ14                        0x0E
+#define IRQ15                        0x0F
+#define IRQ16                        0x10
+#define IRQ17                        0x11
+#define IRQ18                        0x12
+#define IRQ19                        0x13
+#define IRQ20                        0x14
+#define IRQ21                        0x15
+#define IRQ22                        0x16
+#define IRQ23                        0x17
+
+#define ESPI_FCH_PM_ADDR	0xFED80340
 
 struct master_caps {
 	// Channel support by master, bits [0:3]
@@ -155,11 +240,11 @@ struct master_caps {
 	u32 io_mode_quad:1;
 
 	//Alert mode bit [30], 0 - I/O[1], 1 - Dedicated alert pin
-	u32 alert_mode:1;	
+	u32 alert_mode:1;
 
-	//CRC Checking Support by Master, 0 - support, 1 - Doesn't Support  
+	//CRC Checking Support by Master, 0 - support, 1 - Doesn't Support
 	u32 crc_check_support:1;
-}__packed;
+} __packed;
 
 struct espi_master {
 	struct device *dev;
@@ -168,18 +253,18 @@ struct espi_master {
 	u32 mode_bits;
 	u16 flags;
 	struct master_caps caps;
-}__packed;
+} __packed;
 
 struct espi_device {
-    u8 io_mode;
-    u8 channel_modes;
-    u8 op_freq;
+	u8 io_mode;
+	u8 channel_modes;
+	u8 op_freq;
 };
 
 struct config {
-    u8 io_mode;
-    u8 channel_mode;
-    u8 op_freq;
+	u8 io_mode;
+	u8 channel_mode;
+	u8 op_freq;
 };
 
 union io_data {
@@ -195,68 +280,83 @@ struct periph_io_rw {
 } __packed;
 
 struct periph_mem_rw {
-        u32 addr;
-        u32 data;
+	u32 addr;
+	u32 data;
+} __packed;
+
+struct vw_data {
+	u8 index;
+	u8 vw_data;
+} __packed;
+
+struct vw_packet {
+	u8 index_count;
+	struct vw_data *data;
+} __packed;
+
+struct conf_vw_index {
+	u8 index;
+	u8 group;
 } __packed;
 
 enum espi_cmd_type {
-    SET_CONFIGURATION = 0,
-    GET_CONFIGURATION = 1,
-    IN_BAND_RESET = 2,
-    PERIPHERAL_CHNL = 4,
-    VW_CHNL = 5,
-    OOB_CHNL = 6,
-    FLASH_CHNL = 7,
+	SET_CONFIGURATION = 0,
+	GET_CONFIGURATION = 1,
+	IN_BAND_RESET = 2,
+	PERIPHERAL_CHNL = 4,
+	VW_CHNL = 5,
+	OOB_CHNL = 6,
+	FLASH_CHNL = 7,
 };
 
 /* TX Header and data packet */
 union espi_txhdr0 {
-    u32 val;
-    struct {
-        u32 cmd_type:3;
-        u32 cmd_status:1;
-        u32 slave_sel:2;
-        u32 rsvd:2;
-        u32 hdata0:8;
-        u32 hdata1:8;
-        u32 hdata2:8;
-    };
+	u32 val;
+	struct {
+		u32 cmd_type:3;
+		u32 cmd_status:1;
+		u32 slave_sel:2;
+		u32 rsvd:2;
+		u32 hdata0:8;
+		u32 hdata1:8;
+		u32 hdata2:8;
+	};
 } __packed;
 
 union espi_txhdr1 {
-    u32 val;
-    struct {
-        u32 hdata3:8;
-        u32 hdata4:8;
-        u32 hdata5:8;
-        u32 hdata6:8;
-    };
+	u32 val;
+	struct {
+		u32 hdata3:8;
+		u32 hdata4:8;
+		u32 hdata5:8;
+		u32 hdata6:8;
+	};
 } __packed;
 
 union espi_txhdr2 {
-    u32 val;
-    struct {
-        u32 hdata7:8;
-        u32 rsvd:24;
-    };
+	u32 val;
+	struct {
+		u32 hdata7:8;
+		u32 rsvd:24;
+	};
 } __packed;
 
 union espi_txdata {
-    u32 val;
-    struct {
-        u32 dbyte0:8;
-        u32 dbyte1:8;
-        u32 dbyte2:8;
-        u32 dbyte3:8;
-    };
+	u32 val;
+	struct {
+		u32 dbyte0:8;
+		u32 dbyte1:8;
+		u32 dbyte2:8;
+		u32 dbyte3:8;
+	};
 } __packed;
 
 struct espi_txcmd {
-    union espi_txhdr0 hdr0;
-    union espi_txhdr1 hdr1;
-    union espi_txhdr2 hdr2;
-    union espi_txdata data;
-    u32 expected_status_codes;
+	union espi_txhdr0 hdr0;
+	union espi_txhdr1 hdr1;
+	union espi_txhdr2 hdr2;
+	union espi_txdata *data;
+	u32 expected_status_codes;
 } __packed;
 
 //Data structures for IO decode configuartions
@@ -287,19 +387,19 @@ union io_target_range2 {
 } __packed;
 
 union mmio_target_range4 {
-        u32 val;
-        struct {
-                u32 mmio_range0_size : 16;
-                u32 mmio_range1_size : 16;
-        };
+	u32 val;
+	struct {
+		u32 mmio_range0_size : 16;
+		u32 mmio_range1_size : 16;
+	};
 } __packed;
 
 union mmio_target_range5 {
-        u32 val;
-        struct {
-                u32 mmio_range2_size : 16;
-                u32 mmio_range3_size : 16;
-        };
+	u32 val;
+	struct {
+		u32 mmio_range2_size : 16;
+		u32 mmio_range3_size : 16;
+	};
 } __packed;
 
 struct io_mmio_decode_config {
diff --git a/drivers/spi/espi_bmc_uart.h b/drivers/spi/espi_bmc_uart.h
new file mode 100644
index 000000000..062f0f4ab
--- /dev/null
+++ b/drivers/spi/espi_bmc_uart.h
@@ -0,0 +1,121 @@
+#include <linux/ioport.h>
+#include <linux/io.h>
+#include <linux/serial_reg.h>
+
+#define PORT1 0x3F8  /* Port Address Goes Here */
+#define outb_s(port,command) outb(command,port)
+#define inb_s(port) inb(port)
+
+
+void sio_write( int reg, int val);
+void sio_enable(void);
+unsigned int sio_read(int reg);
+void sio_lock(void);
+void sio_select_logical_dev( int ldev);
+void sio_enable_logical_dev( int ldev);
+void sio_disable_logical_dev( int ldev);
+void sio_enable_interrupt(void);
+void bmc_uart_enable_ioctl(void);
+
+
+void sio_write( int reg, int val)
+{
+	outb(reg, 0x2E);
+	outb(val, 0x2F);
+}
+
+unsigned int sio_read( int reg)
+{
+	unsigned int ret;
+	outb(reg, 0x2e);
+	ret = inb(0x2f);
+	return ret;
+}
+
+void sio_enable(void)
+{
+	outb(0xaa, 0x2e);
+	outb(0xa5, 0x2e);
+	outb(0xa5, 0x2e);
+}
+
+
+void sio_lock(void)
+{
+	outb(0xaa, 0x2e);
+}
+
+void sio_select_logical_dev( int ldev)
+{
+	sio_write( 0x7, ldev);
+}
+
+void sio_enable_logical_dev( int ldev)
+{
+	sio_write( 0x30, ldev);
+}
+
+void sio_disable_logical_dev( int ldev)
+{
+	sio_write(0x30, 0);
+}
+
+
+
+void sio_enable_interrupt(void)
+{
+	/* Enable SIO Password register*/
+	sio_enable();
+
+	/* Select SIO logical device SUART1*/
+	sio_select_logical_dev(2);
+	sio_read(0x7);
+
+	/* disable SUART1*/
+	sio_disable_logical_dev(1);
+	sio_read(0x30);
+
+	/*set SUART1 I/O port to 0x3F8 */
+	sio_write(0x60, 3);
+	sio_write(0x61, 0xf8);
+
+
+	/* Read SIO Identification bit */
+	sio_read(0x20);
+
+	/* Read SUART1 Base Address */
+	sio_read(0x60);
+	sio_read(0x61);
+
+	sio_write( 0x70, 0x04);
+	/* Change serIRQ type to eSPI mode */
+	sio_write( 0x71, 0x00);
+
+	/* Read BMC to SIO interrupt ststus */
+	sio_read(0x21);
+	sio_read( 0x70);
+
+	/* Read serIRQ interrupt type for SUART1 */
+	sio_read( 0x71);
+
+	sio_enable_logical_dev(1);
+	sio_read(0x30);
+	sio_lock();
+}
+
+void bmc_uart_enable_ioctl()
+{
+	outb_s(PORT1 + UART_IER , 0);        /* Turn off interrupts - Port1 */
+	outb_s(PORT1 + UART_LCR , UART_LCR_DLAB);  /* SET DLAB ON */
+
+	outb_s(PORT1 + UART_DLL , 0x01);
+	outb_s(PORT1 + UART_DLM , 0x00);  /* Set Baud rate - Divisor Latch High Byte */
+
+	outb_s(PORT1 + UART_LCR , UART_LCR_WLEN8);  /* 8 Bits, No Parity, 1 Stop Bit */
+
+	outb_s(PORT1 + UART_FCR , UART_FCR_ENABLE_FIFO);
+	outb_s(PORT1 + UART_LCR , inb_s(PORT1 + UART_LCR)&(~UART_LCR_DLAB));
+	outb_s(PORT1 + UART_IER , UART_IER_RDI);
+
+	sio_enable_interrupt();
+}
diff --git a/drivers/spi/espi_slave.h b/drivers/spi/espi_slave.h
index 1a02ef93b..e519769b5 100644
--- a/drivers/spi/espi_slave.h
+++ b/drivers/spi/espi_slave.h
@@ -1,3 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
+ *
+ * AMD eSPI controller driver
+ *
+ * Copyright (c) 2020, Advanced Micro Devices, Inc.
+ */
+
 #define ESPI_SLAVE_GENERAL_CAPS_CFG				0x08
 
 #define  ESPI_SLAVE_CRC_ENABLE				(1 << 31)
@@ -24,7 +31,7 @@
 #define  ESPI_SLAVE_OP_FREQ_SEL_SHIFT			20
 #define  ESPI_SLAVE_OP_FREQ_SEL_MASK			~(0x7 << ESPI_SLAVE_OP_FREQ_SEL_SHIFT)
 #define  ESPI_SLAVE_OP_FREQ_SEL_VAL(x)			((x) << ESPI_SLAVE_OP_FREQ_SEL_SHIFT)
-#define  ESPI_SLAVE_OP_FREQ_SEL_16_MHZ          	ESPI_SLAVE_OP_FREQ_SEL_VAL(0)
+#define  ESPI_SLAVE_OP_FREQ_SEL_16_MHZ			ESPI_SLAVE_OP_FREQ_SEL_VAL(0)
 #define  ESPI_SLAVE_OP_FREQ_SEL_33_MHZ			ESPI_SLAVE_OP_FREQ_SEL_VAL(2)
 #define  ESPI_SLAVE_OP_FREQ_SEL_66_MHZ			ESPI_SLAVE_OP_FREQ_SEL_VAL(4)
 
@@ -73,6 +80,7 @@
 static inline bool espi_slave_supports_quad_io(u32 caps)
 {
 	u32 mode = caps & ESPI_SLAVE_IO_MODE_SUPP_MASK;
+
 	return (mode == ESPI_SLAVE_IO_MODE_SUPP_SINGLE_QUAD) ||
 		(mode == ESPI_SLAVE_IO_MODE_SUPP_SINGLE_DUAL_QUAD);
 }
@@ -80,13 +88,14 @@ static inline bool espi_slave_supports_quad_io(u32 caps)
 static inline bool espi_slave_supports_dual_io(u32 caps)
 {
 	u32 mode = caps & ESPI_SLAVE_IO_MODE_SUPP_MASK;
+
 	return (mode == ESPI_SLAVE_IO_MODE_SUPP_SINGLE_DUAL) ||
 		(mode == ESPI_SLAVE_IO_MODE_SUPP_SINGLE_DUAL_QUAD);
 }
 
 static inline bool espi_slave_supports_single_io(u32 caps)
 {
-	//As per register spec single IO mode is supported by default 
+	//As per register spec single IO mode is supported by default
 	return true;
 }
 
-- 
2.34.1

